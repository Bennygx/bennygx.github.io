<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VSCode常用快捷键大全</title>
      <link href="/2020/04/19/tools/vscode-shortcuts.html"/>
      <url>/2020/04/19/tools/vscode-shortcuts.html</url>
      
        <content type="html"><![CDATA[<p>我之前也是用过很多代码编辑器，从<code>NotePad++</code>、<code>SublimeText</code>一直到<code>PHPStorm</code>，最后<code>VSCode</code>。这个过程每一个编辑器我都折腾了很多配置，插件和主题。开发者的编辑器就等同于一个刀客的随身佩刀，一个枪手的随身配枪。一个好的装备的配件可以大大提升我们的战斗力。</p><p>所以对于一个好的程序员，一个好的代码编辑器可以起到很大的作用，在开发的过程中可以给我们带来很多便利、帮助、效率和影响。甚至一个好的编辑器可以给开发者日常编程中带来更高的喜悦感。</p><p>枪手挑选一把枪会通过几个纬度来选择：重量，击倒力，子弹量和精准度等等。那对开发者来说也一样的，我们会考虑这个编辑器的插件，扩展性，兼容性，功能性，美观和快捷键等等。</p><p>其中我们最在乎的就是：</p><ul><li>“<strong>有多少实用的插件给我们带来开发便利和效率</strong>”</li><li>“<strong>能否兼容我们的编程语言</strong>”</li><li>“<strong>有没有定义或者方法跳转，让我在复杂的代码中定位到方法、变量和函数</strong>”</li><li>“<strong>代码要看的舒服，代码高亮要优美好看，养眼</strong>”</li><li>“<strong>有常用的快捷键，提高开发效率（最好让我不需要用鼠标）</strong>”</li></ul><blockquote><p>🌟 总结一下其实就是“让我们写代码<strong>更快速</strong>，<strong>更愉悦</strong>，<strong>更舒服</strong>”</p></blockquote><hr><h1 id="「始」前沿"><a href="#「始」前沿" class="headerlink" title="「始」前沿"></a>「始」前沿</h1><p><img src="https://img-blog.csdnimg.cn/20200417215902749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""><br>要全面教大家高效使用 VSCode，就要讲到 3 大板块：<code>快捷键</code>，<code>插件</code>和<code>配置</code>。因为内容非常之多，<code>所以我拆分成了3篇文章提供给大家学习。</code>（感兴趣的童鞋可以关注一下哦 😁）</p><p>这篇文章主要详细讲解<code>VSCode</code>的常用快捷键，让大家在 VSCode 中编写代码时，更加的顺手，基本可以脱离鼠标。</p><p><strong>基本上记住这些常用的快捷键，我们就可以马上提高使用 VSCode 的效率，也会提升我们编写代码的速度！</strong></p><p>让我们一起成为 VSCode 的高级玩家！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzExLzE3MTY4NzdiNmRhMzMzNGM?x-oss-process=image/format,png" alt=""></p><h1 id="「一」编辑器使用"><a href="#「一」编辑器使用" class="headerlink" title="「一」编辑器使用"></a>「一」编辑器使用</h1><p>先讲讲使用编辑器功能的快捷键，这些可以让我们更快捷和顺手的使用 VSCode 的一些常用功能。同时可以使用这些快捷键挖掘更多编辑器的隐藏功能哦。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="快捷键列表查看「View-Shortcut」"><a href="#快捷键列表查看「View-Shortcut」" class="headerlink" title="快捷键列表查看「View Shortcut」"></a>快捷键列表查看「View Shortcut」</h2><p>如果想查看所有快捷键的童鞋，可以使用一下快捷键：</p><blockquote><p>Mac：<code>Command</code> + <code>K</code>，再按<code>Command</code> + <code>S</code></p><p>Linux/Windows：<code>Ctrl</code> + <code>K</code>，再按<code>Ctrl</code> + <code>S</code></p></blockquote><blockquote><p>🌟 如果需要快速查看某一个特定的快捷键，只需要快捷键列表上方的搜索栏输入直接搜索即可</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="快速打开文件「Quick-open」"><a href="#快速打开文件「Quick-open」" class="headerlink" title="快速打开文件「Quick open」"></a>快速打开文件「Quick open」</h2><p>可以用于快速搜索，然后打开项目中的文件，当你想在一个大型项目中打开某一个代码文件时，此方法非常实用。</p><blockquote><p>Mac: <code>Command</code> + <code>P</code></p><p>Linux/Windows：<code>Ctrl</code> + <code>P</code></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZhNTc5MmU0MGFmNmQ?x-oss-process=image/format,png" alt=""></p><blockquote><p>🌟 小技巧</p><ul><li>输入<code>?</code>可以查看帮助文档</li><li>搜索中会优先列出最近打开过的文件</li><li>如果想打开多个文件有两种方法：（会在背后打开新的文件，搜索不会被关闭）<ul><li>打开新文件 Mac: <code>Option</code> + <code>→</code> 或者 Linux/Windows：<code>Alt</code> + <code>→</code></li><li>多窗口打开 Mac: <code>Command</code> + <code>→</code> 或者 Linux/Windows：<code>Ctrl</code> + <code>→</code></li></ul></li></ul></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="编辑器命令「Command-Palette」"><a href="#编辑器命令「Command-Palette」" class="headerlink" title="编辑器命令「Command Palette」"></a>编辑器命令「Command Palette」</h2><p>在搜索加上<code>&gt;</code>前缀就可以调用命令了。编辑器的命令可以做很多，可以快速搜索快捷键，还可以执行插件的一些命令，非常实用哦！</p><blockquote><p>Mac: <code>Command</code> + <code>P</code></p><p>Linux/Windows：<code>Ctrl</code> + <code>P</code></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZhNmQzMmE1Mzk1MzI?x-oss-process=image/format,png" alt=""></p><blockquote><p>🌟 小技巧</p><p>想快速查看快捷键按钮也可以通过这种方式搜索。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="拆分编辑器「Split-Editor」"><a href="#拆分编辑器「Split-Editor」" class="headerlink" title="拆分编辑器「Split Editor」"></a>拆分编辑器「Split Editor」</h2><p>在开发的过程中，我们会经常打开几个文件同时编辑，特别是高度封装的代码就会同时在更改多个文件。</p><p>前端就更不用说的，很多时候我们都在同时编辑 HTML，CSS 和 JavaScript 文件。</p><p>编写 Vue 的时候就更难受了，HTML 和 CSS 和脚本都是在一个文件中，代码会非常的长，把当前文件在同一个编辑器拆分开，然后分别滑动到 HTML，CSS 和脚本部分就可以同时更改了。​</p><blockquote><p>Mac: <code>Command</code> +<code>\</code> 或者 <code>2,3,4</code></p><p>Windows: <code>Shift</code> + <code>Alt</code> + <code>\</code> 或者 <code>2,3,4</code></p><p>Linux: <code>Shift</code> + <code>Alt</code> + <code>\</code> 或者 <code>2,3,4</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200414224225531.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="编辑器网格布局「Editor-Grid-Layout」"><a href="#编辑器网格布局「Editor-Grid-Layout」" class="headerlink" title="编辑器网格布局「Editor Grid Layout」"></a>编辑器网格布局「Editor Grid Layout」</h2><p>默认情况下，编辑器组是垂直列布局的（例如，当您拆分一个编辑器，默认会横向拆分到右手边的）。但是很多时候拆分了多几个编辑器就会发现每个编辑器的宽度会越来越窄，可视度就会大大下降。这个时候我们希望可以使用网格布局。所以我们可以用编辑器的<code>2x2 网格</code>布局。</p><p><img src="https://img-blog.csdnimg.cn/20200417093310262.gif" alt=""></p><p>首先我们需要创建空的编辑器组：打开方式<code>查看</code> &gt; <code>编辑器布局</code> &gt; <code>2x2 网格</code>：</p><p><img src="https://img-blog.csdnimg.cn/20200417165952778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""></p><p>默认情况下，关闭编辑器组的最后一个编辑器也将关闭整个编辑组，下次要使用的时候需要重新开启网格布局，但是我们可以在<code>setting.json</code>的配置里改变<code>workbench.editor.closeEmptyGroups: false</code>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="快速打开和关闭侧边栏「Opening-and-Closing-the-Sidebar」"><a href="#快速打开和关闭侧边栏「Opening-and-Closing-the-Sidebar」" class="headerlink" title="快速打开和关闭侧边栏「Opening and Closing the Sidebar」"></a>快速打开和关闭侧边栏「Opening and Closing the Sidebar」</h2><p>在我们专注于编程的时候，左边的侧边栏会占用我们一定的宽度，特别是使用双屏（尤其是竖向的屏幕）或者是使用拆分编辑器模式。​ 收起侧边栏可以帮我们节省很多空间。</p><blockquote><p>Mac: <code>Command</code> + <code>B</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>B</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020041721395828.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="快速打开集成终端「Open-new-Terminal」"><a href="#快速打开集成终端「Open-new-Terminal」" class="headerlink" title="快速打开集成终端「Open new Terminal」"></a>快速打开集成终端「Open new Terminal」</h2><p>在开发的过程中，我们经常需要用到终端来执行命令。快速打开终端会给我们带来很多便捷。</p><blockquote><p>Mac: <code>Control</code> + `</p><p>Windows/Linux: <code>Ctrl</code> + `</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200418203902969.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzExLzE3MTY4NzdiNmRhMzMzNGM?x-oss-process=image/format,png" alt=""></p><h1 id="「二」辅助代码编写"><a href="#「二」辅助代码编写" class="headerlink" title="「二」辅助代码编写"></a>「二」辅助代码编写</h1><p>接下来我们来讲讲在编程中常用的辅助快捷键。这些快捷键可以辅助我们提升编写代码的速度和效率，让我们的双手更集中 ​ 在键盘上，减少消耗在键盘和鼠标切换过程的时间。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="合并行「Join-Line」"><a href="#合并行「Join-Line」" class="headerlink" title="合并行「Join Line」"></a>合并行「Join Line」</h2><blockquote><p>Mac：<code>Control</code> + <code>J</code></p><p>Linux/Windows：使用上面说到的快捷键打开快捷键查询列表，搜索”合并行”（<code>editor.action.joinLines</code>），鼠标放在合并行的快捷键上，然后点击编辑图标，这里可以设置一个你喜欢的快捷键。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200413170609964.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="代码格式化「Code-Formatting」"><a href="#代码格式化「Code-Formatting」" class="headerlink" title="代码格式化「Code Formatting」"></a>代码格式化「Code Formatting」</h2><p>这个快捷键帮我们快速调整代码缩减，不过我更加推荐使用<code>Prettier</code>插件，这边文章后面会讲到。</p><blockquote><p>Mac: <code>Shift</code> + <code>Option</code> + <code>F</code></p><p>Windows：<code>Shift</code> + <code>Alt</code> + <code>F</code></p><p>Linux：<code>Ctrl</code> + <code>Shift</code> + <code>I</code></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZlNzcxY2M4YWY0Njg?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="清楚多余空格「Trim-Trailing-White-Space」"><a href="#清楚多余空格「Trim-Trailing-White-Space」" class="headerlink" title="清楚多余空格「Trim Trailing White Space」"></a>清楚多余空格「Trim Trailing White Space」</h2><p>这个命令帮助我们清楚代码前后的多余空格，如果我们项目有设置严格的 Lint 规范，这个会帮我们减少多余空格的报错。</p><blockquote><p>Mac: <code>Command</code> + <code>K</code> <code>Command</code> + <code>X</code></p><p>Windows/Linux：<code>Ctrl</code> + <code>K</code> <code>Ctrl</code> + <code>X</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200413170524688.gif" alt=""></p><blockquote><p>🌟 小技巧</p><p>这个功能是可以自动执行的，不需要我们一个个选择去清除，我们可以在 VSCode 的配置里面设置自动清除。下面教大家两种配置方式。</p></blockquote><h3 id="使用-settings-json"><a href="#使用-settings-json" class="headerlink" title="使用 settings.json"></a>使用 settings.json</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEzLzE3MTZmNTQ4ZDU2ZGRlMGI?x-oss-process=image/format,png" alt=""></p><ol><li>打开<code>编辑器命令</code>（Mac：<code>Command</code>+<code>P</code>/Windows：<code>Ctrl</code>+<code>P</code>）</li><li>在搜索框输入<code>&gt; Open Settings</code>，然后选择<code>首选项：打开设置(json)</code></li><li>然后 settings.confg 中加入<code>&quot;files.trimTrailingWhitespace&quot;: true</code>，如果已存在这个配置，确保值是<code>true</code>。</li><li>保存文件即可生效（如果没有马上生效，可以重启 VSCode）</li></ol><h3 id="使用可视化（UI）设置"><a href="#使用可视化（UI）设置" class="headerlink" title="使用可视化（UI）设置"></a>使用可视化（UI）设置</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEzLzE3MTZmNTljZWU5MDQxYTE?x-oss-process=image/format,png" alt=""></p><ol><li>打开<code>编辑器命令</code>（Mac：<code>Command</code>+<code>P</code>/Windows：<code>Ctrl</code>+<code>P</code>）</li><li>在搜索框输入<code>&gt; Open Settings</code>，然后选择<code>首选项：打开设置(ui)</code></li><li>在<code>文本编辑器</code>&gt;<code>文件</code>中找到<code>Trim Trailling Whitespace</code>并且勾上（我们也可以在搜索框直接输入<code>Trim Trailling Whitespace</code>快速找到这个配置的位置），可参考下面的截图。</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEzLzE3MTZmNWM1NzljMTliZDE?x-oss-process=image/format,png" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="代码折叠「Code-Folding」"><a href="#代码折叠「Code-Folding」" class="headerlink" title="代码折叠「Code Folding」"></a>代码折叠「Code Folding」</h2><p>在开发项目中，很多时候前端的代码在单个文件下都会越写越多，当我们想专注看一部分或者寻找某段代码时就颇有困难了 ​。一般这个时候我们都会把一些不重要的代码段折叠起来。但是手动用鼠标一个一个点击效率是很低的。代码折叠快捷键在这种情况就非常实用了。</p><h3 id="折叠代码快捷键"><a href="#折叠代码快捷键" class="headerlink" title="折叠代码快捷键"></a>折叠代码快捷键</h3><blockquote><p>Mac: <code>Command</code> + <code>Option</code> + <code>[</code></p><p>Windows/linux: <code>Ctrl</code> + <code>Shift</code> + <code>[</code></p></blockquote><h3 id="展开代码快捷键"><a href="#展开代码快捷键" class="headerlink" title="展开代码快捷键"></a>展开代码快捷键</h3><blockquote><p>Mac: <code>Command</code> + <code>Option</code> + <code>]</code></p><p>Windows/linux: <code>Ctrl</code> + <code>Shift</code> + <code>]</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200413163137331.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="往上-下复制行「Copy-Line-Up-Down」"><a href="#往上-下复制行「Copy-Line-Up-Down」" class="headerlink" title="往上/下复制行「Copy Line Up/Down」"></a>往上/下复制行「Copy Line Up/Down」</h2><p>在写代码的时候，我们经常会编写一些非常相似的代码连续几遍或者是先复制然后稍微更改一下。​ 特别是在 JS 中的<code>require</code>或者<code>import</code>这种引入包的时候。如果我们需要选中一行然后复制，回车然后粘贴，这波操作确实不够快呀，有没有更快速的复制方式呢？有的！</p><blockquote><p>Mac: <code>Shift</code> + <code>Option</code> + <code>⬆️ / ⬇️</code></p><p>Windows: <code>Shift</code> + <code>Alt</code> + <code>⬆️ / ⬇️</code></p><p>Linux: <code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>⬆️ / ⬇️</code></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEzLzE3MTcyOWU1MTQ3NDAwNzY?x-oss-process=image/format,png" alt=""></p><p>当然，如果你不喜欢这个默认的快捷键，可以在快捷键列表中修改。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="选择单词「Select-Word」"><a href="#选择单词「Select-Word」" class="headerlink" title="选择单词「Select Word」"></a>选择单词「Select Word」</h2><p>很多时候在开发过程中，我们都会需要多个相同单词（多个变量名）同时修改，可能是局部方法中的单词，也可能是这个文件中的同名单词的修改。比较古老的方法就是用全局搜索然后替换。</p><p>在 VSCode 中有一个更加快速和简便的方法，并且可以让你局部选择或者是快速全部选择。选中后就可以同时修改选中的单词了。</p><p><img src="https://img-blog.csdnimg.cn/20200417212339752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="局部选择"><a href="#局部选择" class="headerlink" title="局部选择"></a>局部选择</h3><p>首先选中你需要的单词然后按下面的快捷键即可：</p><blockquote><p>Mac: <code>Command</code> + <code>D</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>D</code></p></blockquote><p>如果我们多次按下快捷键，编辑器会继续往下找到相同的单词，然后自动选中。</p><h3 id="全局选中"><a href="#全局选中" class="headerlink" title="全局选中"></a>全局选中</h3><p>一样首先选中你需要的单词，然后按下快捷键即可：</p><blockquote><p>Mac: <code>Command</code> + <code>Shift</code> + <code>L</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>Shift</code> + <code>L</code></p></blockquote><p>这个唯一不一样的就是，这个会找到当前文件下的所有相同的单词，并且选中。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="跳转到特定行数「Navigate-to-a-Specific-Line」"><a href="#跳转到特定行数「Navigate-to-a-Specific-Line」" class="headerlink" title="跳转到特定行数「Navigate to a Specific Line」"></a>跳转到特定行数「Navigate to a Specific Line」</h2><p>在排查错误的时候经常会用到的一个快捷键，我们需要找到当前文件下特定行的代码。</p><blockquote><p>Mac: <code>Command</code> + <code>G</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>G</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200417220341731.gif" alt=""></p><blockquote><p>🌟 小技巧<br>结合我们上面学习到的，我们也可以先使用快捷键（Mac：<code>Command</code> + <code>P</code>）打开<code>编辑器命令</code> 然后输入<code>:</code> 再输入行数即可。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="文件中跳转特定符号「Go-to-Symbol-in-File」"><a href="#文件中跳转特定符号「Go-to-Symbol-in-File」" class="headerlink" title="文件中跳转特定符号「Go to Symbol in File」"></a>文件中跳转特定符号「Go to Symbol in File」</h2><p>这里我讲解一下<code>符号</code>指的是什么，它就是在代码中的<code>方法</code>、<code>类</code>或者是<code>属性</code>。</p><p>所以在一个比较大的代码文件中，这个快捷键会非常实用。能让我们快速找到想要编辑的方法、属性或者类！</p><blockquote><p>Mac: <code>Command</code> + <code>Shift</code> + <code>O</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>Shift</code> + <code>O</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200417221237145.gif" alt=""></p><blockquote><p>🌟 小技巧</p><p>如果文件中的<code>符号</code>过多，我们可以在<code>@</code>后面加上<code>:</code>，就可以为所有符号分类让，我们更好找到需要的符号和位置。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020041722153432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="项目中跳转特定符号-「Go-to-Symbol-in-Workspace」"><a href="#项目中跳转特定符号-「Go-to-Symbol-in-Workspace」" class="headerlink" title="项目中跳转特定符号 「Go to Symbol in Workspace」"></a>项目中跳转特定符号 「Go to Symbol in Workspace」</h2><p>这个快捷键与文件中跳转的雷同，唯一区别就是这个可以搜索出整个项目中的<code>方法</code>、<code>类</code>和<code>属性</code>，并且快速跳转到这些符号的位置。</p><blockquote><p>Mac: <code>Command</code> + <code>T</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>T</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200417222512659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="删除整个单词「Delete-Previous-Word」"><a href="#删除整个单词「Delete-Previous-Word」" class="headerlink" title="删除整个单词「Delete Previous Word」"></a>删除整个单词「Delete Previous Word」</h2><p>在我们打错一个单词的时候，我们经常都会连续按删除键直到我们想要重新开始的地方。其实对我们程序员来说，打字都是飞快的，重新打过远远比一个一个字母删除来的快的多。（有些童鞋可能还会用鼠标来选中要删除的，其实在写代码的时候，可以不用鼠标尽量不用鼠标，这样速度会更快哦）只要按下这个快捷键就可以整个单词删除掉。</p><blockquote><p>Mac: <code>Command</code> + <code>Delete</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>Backspace</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020041722305847.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="按单词选择「Select-by-words」"><a href="#按单词选择「Select-by-words」" class="headerlink" title="按单词选择「Select by words」"></a>按单词选择「Select by words」</h2><p>为了在编程中脱离使用鼠标，我们经常需要选中一行代码中的几个单词，这个快捷键可以让我们快速做到这样的操作。</p><blockquote><p>Mac: <code>Command</code> + <code>Shift</code> + <code>← / →</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>Shift</code> + <code>← / →</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020041722355970.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="快速复制当前行「Duplicate-Line」"><a href="#快速复制当前行「Duplicate-Line」" class="headerlink" title="快速复制当前行「Duplicate Line」"></a>快速复制当前行「Duplicate Line」</h2><p>用过 IDE 的基本都很熟悉这个操作，就是快速往下复制当前行的代码。这个在编程过程中也是非常实用。​</p><blockquote><p>其实我们可以选中一段代码，按下这个快捷键也可以 ​ 往下复制整个内容哦。</p></blockquote><blockquote><p>Mac: <code>Command</code> + <code>Shift</code> + <code>D</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>Shift</code> + <code>D</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200417223806470.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="删除一行「Deleting-a-Line」"><a href="#删除一行「Deleting-a-Line」" class="headerlink" title="删除一行「Deleting a Line」"></a>删除一行「Deleting a Line」</h2><p>用于快速删除一整行的代码。</p><blockquote><p>Mac: <code>Command</code> + <code>X</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>X</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200417224040321.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="往上-下添加同时编辑「Add-Cursor-Above-Below」"><a href="#往上-下添加同时编辑「Add-Cursor-Above-Below」" class="headerlink" title="往上/下添加同时编辑「Add Cursor Above/Below」"></a>往上/下添加同时编辑「Add Cursor Above/Below」</h2><p>用过<code>SublimeText</code>的同学应该都很熟悉这个功能。我们可以在多个位置添加鼠标编辑点，然后同时编辑。VSCode 也有这样的快捷键。</p><blockquote><p>Mac: <code>Command</code> + <code>Option</code> + <code>↑ / ↓</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>Alt</code> + <code>↑ / ↓</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200417224752297.gif#pic_center" alt=""></p><blockquote><p>🌟 小技巧</p><p>如果想和上图一样，在属性的单词前添加好同时编辑鼠标点后，一下子即跳到所有属性名的最后面，我们只需要先在所有名字前面加入同时编辑鼠标然后用一下快捷键即可：</p><hr><p>Mac: <code>Command</code> + <code>→</code></p><p>Windows/Linux: <code>Ctrl</code> + <code>→</code></p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="多行选中同时编辑-「Column-Selection」"><a href="#多行选中同时编辑-「Column-Selection」" class="headerlink" title="多行选中同时编辑 「Column Selection」"></a>多行选中同时编辑 「Column Selection」</h2><p>这个快捷键需要配合鼠标一起使用。我们经常会在编写代码的时候选中一大串代码进行编辑，这个时候这个快捷键就非常使用。</p><p><strong>我们还可以按住这个快捷键，然后选择我们需要同时修改的位置，然后多个鼠标位置同时编辑哦！</strong></p><blockquote><p>Mac: <code>Shift</code> + <code>Option</code></p><p>Windows/Linux: <code>Shift</code> + <code>Alt</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200417230233688.gif" alt=""></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzEyLzE3MTZkMWNjMDhjNTA1NDM?x-oss-process=image/format,png" alt=""></p><h2 id="修改“符号”-「Rename-Symbol」"><a href="#修改“符号”-「Rename-Symbol」" class="headerlink" title="修改“符号” 「Rename Symbol」"></a>修改“符号” 「Rename Symbol」</h2><p>VSCode 默认支持 JavaScript 和 TypeScript 的<code>方法名</code>、<code>类名</code>和<code>属性名</code>等符号修改。在修改后，文件下引用到这些符号的地方都会被自动的同时修改。其他语言的支持需要插件。</p><blockquote><p>Mac: <code>F2</code></p><p>Windows/Linux: <code>F2</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020041723052880.gif" alt="在这里插入图片描述"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzExLzE3MTY4NzdiNmRhMzMzNGM?x-oss-process=image/format,png" alt=""></p><h1 id="「待续」总结"><a href="#「待续」总结" class="headerlink" title="「待续」总结"></a>「待续」总结</h1><p>这里我已介绍完所有常用的快捷键和编辑器中的使用小技巧。很多需要学习快捷键的小伙伴们不可能一下子就会使用和记住。温馨提示：​<strong>所以可以先收藏本文章，当需要的时候就可以马上搜索找到并使用</strong>。当我们用多了，也就自然而然熟能生巧了。</p><p>当我们习惯于使用这些快捷键，我们就会发现我们代码编写速度都会有所提升的。</p><p><strong>下一篇 VSCode 高级玩家宝典，我会讲解 VSCode 中的所有常用插件（包括前端/后端），敬请期待！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> VSCode Shortcuts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端必看的8个HTML+CSS技巧</title>
      <link href="/2020/04/06/frontend/8-html-css-tips.html"/>
      <url>/2020/04/06/frontend/8-html-css-tips.html</url>
      
        <content type="html"><![CDATA[<p>CSS 是一个很独特的语言。看起来非常简单，但是某种特殊效果看似简单，实现起来就颇有难度。这篇文章主要是给在学习前端的童鞋分享一些新的 CSS 技巧，一些在前端教程和培训课堂中不会讲到的知识。第二就是让还在前端开发这条道路上的童鞋们，重新燃起对前端排版和特效的热爱和热情！🔥</p><hr><h1 id="一、固定底部内容"><a href="#一、固定底部内容" class="headerlink" title="一、固定底部内容"></a>一、固定底部内容</h1><p><img src="https://img-blog.csdnimg.cn/20200401142526736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="固定底部内容"></p><p>这种是一个非常常见的布局方式，但是对于新手来说是比较常见的难题。</p><p>这种布局方式在后台管理系统中比较常见，当我们内容不足浏览器窗口高度时，底部内容需要固定在底部。当内容超出了浏览器窗口高度，就会随着内容往后推。</p><p>在有 CSS3 之前，实现这个效果是颇有难度的。浏览器窗口高度是会根据不同用户打开浏览器的情况，屏幕大小的差异和浏览器的缩放比例而变。我们需要借助 JavaScript 来实时获取浏览器高度进行运算才能实现。虽然说标题是说“固定”底部，但是我们想要的效果不是<code>position: fixed</code>。使用固定定位，在内容高于窗口高度时，就会挡住我们的内容。</p><p>随着 CSS3 的来临，最完美的实现方式是使用<code>Flexbox</code>。实现的关键就是使用不太被关注的<code>flex-grow</code>属性，可以在我们的内容标签元素（比如<code>div</code>）中使用。在我们下面的例子里使用了<code>main</code>标签。</p><hr><p>我来讲解一下实现原理吧。</p><p><img src="https://img-blog.csdnimg.cn/20200401140715577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""></p><p><code>flew-grow</code>是用来控制一个 flex 元素相对它同等级 flex 元素的自身可扩充的空间。如果我们使用<code>flex-grow: 0</code>，那这个 flex 元素就完全不会扩展了。所以我们需要把头部和底部之间的内容标签元素设置为<code>flex-grow: 1</code>或者<code>flex-grow: auto</code>，这样内容部分就会自动填充满头部和底部之外的所有空间。</p><p>为了避免底部内容受内容部分扩充空间的影响，我们给<code>footer</code>底部元素<code>flex-shrink: 0</code>属性。<code>flex-shrink</code>的作用与<code>flex-grow</code>是恰恰相反，用来控制 flex 元素收缩的空间，这里我们给了<code>flex-shrink: 0</code>就是为了底部<code>footer</code>的大小不受影响。</p><p>我们直接上 HTML 和 CSS 代码看看是怎么实现的。</p><p>HTML</p><pre><code class="html">&lt;div id=&quot;document&quot;&gt;  &lt;nav&gt;    &lt;h1&gt;头部内容&lt;/h1&gt;  &lt;/nav&gt;  &lt;main&gt;    &lt;p&gt;可以添加更多内容看看底部的变化哦！&lt;/p&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;h1&gt;底部内容&lt;/h1&gt;  &lt;/footer&gt;&lt;/div&gt;</code></pre><p>CSS</p><pre><code class="css">#document {  height: 100vh;  display: flex;  flex-direction: column;  background: #202020;  font-family: microsoft yahei, wenquanyi micro hei, sans-serif !important;}nav,footer {  background: #494949;  display: flex;  justify-content: center;}main {  color: #bdbdbd;  flex: auto;}footer {  flex-shrink: 0;}* {  margin: 0;}h1,p {  padding: 15px;}nav &gt; h1 {  color: #82fcfd;  text-shadow: 1px 1px 4px #00000080;}footer &gt; h1 {  color: #82fcfd;  text-shadow: 1px 1px 4px #00000080;}</code></pre><blockquote><p>🌟<strong>知识点总结：</strong></p><ul><li><strong>flex-grow</strong> — 是用来控制一个 flex 元素相对它同等级 flex 元素的自身可扩充的空间</li><li><strong>flex-shrink</strong> — 作用与<code>flex-grow</code>是恰恰相反，用来控制 flex 元素收缩的空间</li></ul><p><a href="http://tridiamond.me/frontend-tutorials/stickyFooter/"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/stickyFooter" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="二、悬停放大图片特效"><a href="#二、悬停放大图片特效" class="headerlink" title="二、悬停放大图片特效"></a>二、悬停放大图片特效</h1><p><img src="https://img-blog.csdnimg.cn/20200401220041648.gif#pic_center" alt="悬停放大图片特效"><br>悬停放大图片是一个特别吸引眼球的特效，比较常用于可点击的图片。当用户悬停鼠标在图片上，图片会稍微的放大。</p><p>其实实现这个特效是非常简单的。首先我们需要一个<code>div</code>包裹这<code>img</code>标签，这个包裹层是用来遮挡住图片，当图片放大时不会出现图片超出我们规定的宽高以外。</p><p>首先我们来讲讲<code>div</code>包裹的属性，我们需要给它一个固定的<code>width</code>宽和<code>height</code>高。然后我们必须给予这个元素<code>overflow: hidden</code>属性。让图片放大的时候不会超出这个<code>div</code>元素的宽高。有了这个包裹层，我们就可以编写<code>img</code>的各种效果了。</p><p>我的例子里面用了<code>transform: scale(1,1)</code>作为悬停时的图片特效，这个<code>transform</code>是用于改变任何元素的属性的，然后<code>scale</code>是用于放大（整数就会放大）或者缩小（负数就会缩小）元素的。</p><p>上代码让大家看看：</p><ul><li>html body 中放入</li></ul><pre><code class="html">&lt;div class=&quot;img-wrapper&quot;&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/2020032122230564.png&quot; /&gt;&lt;/div&gt;</code></pre><ul><li>CSS</li></ul><pre><code class="css">.img-wrapper {  width: 400px;  height: 400px;  overflow: hidden;  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);}.img-wrapper img {  height: 400px;  -webkit-transition: 0.3s linear;  transition: 0.3s linear;}.img-wrapper img:hover {  transform: scale(1.1);}.img-wrapper {  display: inline-block;  box-sizing: border-box;  border: 3px solid #000;}</code></pre><p>如果你们想让图片更加炫酷可以加上图片过滤属性<code>filter</code>，让图片变灰或者变深褐色，然后悬停时候出现更加炫酷的颜色变幻。灰化的属性是<code>filter: grayscale(100%);</code>，然后深褐色化的属性是<code>filter: sepia(100%)</code>。其实图片还有很多过滤属性的，大家有兴趣也可以去尝试一下哦！</p><p>加入特殊效果的代码如下：</p><p>HTML</p><pre><code class="html">&lt;!-- 灰度过滤 --&gt;&lt;div class=&quot;img-wrapper&quot;&gt;  &lt;img class=&quot;grayscale-img&quot; src=&quot;https://img-blog.csdnimg.cn/2020032211021728.png&quot; /&gt;&lt;/div&gt;&lt;!-- 深褐色过滤 --&gt;&lt;div class=&quot;img-wrapper&quot;&gt;  &lt;img class=&quot;sepia-img&quot; src=&quot;https://img-blog.csdnimg.cn/2020032122230564.png&quot; /&gt;&lt;/div&gt;</code></pre><p>CSS</p><pre><code class="css">/* ==============* 灰度过滤* ==============*/.grayscale-img {  -webkit-filter: grayscale(100%);  filter: grayscale(100%);}.grayscale-img:hover {  -webkit-filter: grayscale(0);  filter: grayscale(0);}/* ==============* 深褐色过滤* ==============*/.sepia-img {  -webkit-filter: sepia(100%);  filter: sepia(100%);}.sepia-img:hover {  -webkit-filter: sepia(0);  filter: sepia(0);}</code></pre><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>transform</strong> — 用于改变元素</li><li><strong>scale</strong> — 对元素进行放大和缩小</li><li><strong>filter</strong> — 图片过滤器</li><li><strong>grayscale</strong> — 灰度过滤</li><li><strong>sepia</strong> — 深褐色过滤</li></ul><p><a href="http://tridiamond.me/frontend-tutorials/zoomOnHoverImage/"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/zoomOnHoverImage" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="三、瞬间黑暗模式"><a href="#三、瞬间黑暗模式" class="headerlink" title="三、瞬间黑暗模式"></a>三、瞬间黑暗模式</h1><p><img src="https://img-blog.csdnimg.cn/20200402143046993.gif#pic_center" alt=""></p><p>最近微信也逃脱不了黑暗时代的到来，网页也很多都做了黑暗模式的兼容和主题。如果我们在做的一个网站想瞬间实现黑暗模式可以怎么实现呢？</p><p>其实有一个很快的方式，我们可以使用<code>invert</code>和<code>hue-rotate</code>两个 CSS3 过滤器来实现。</p><p><code>filter: invert()</code> — 是从<code>0</code>到<code>1</code>的刻度，<code>1</code>是从白变黑。<br><code>filter: hue-rotate()</code> — 用于改变你元素的颜色，同时或多或少保持原本相同的色系。这个属性的值可以从<code>0deg</code>到<code>360deg</code>。</p><p>在我们页面的<code>body</code>标签上添加这两个属性，我们就可以快速尝试把我们的网站变成”黑暗模式”。这里需要注意的是，如果<code>body</code>和<code>html</code>上没有设置<code>background</code>背景颜色，这个过滤就会不起效了哦。</p><p>CSS 的代码如下：</p><pre><code class="css">html {  background: #fff;}body {  background: #fff;  filter: invert(1) hue-rotate(270deg);}</code></pre><p>实现效果<br><img src="https://img-blog.csdnimg.cn/20200401234411899.gif#pic_center" alt=""></p><p>这里我们会发现图片的颜色会受影响，并不是很美观，使用 css 过滤器是无法完美切换黑暗模式的。不过使用 JavaScript 辅助就可以完美的切换黑暗模式。</p><p>最近出了一个 JavaScript 辅助插件叫<code>Darkmode.js</code>。</p><h2 id="🌓-Darkmode-js"><a href="#🌓-Darkmode-js" class="headerlink" title="🌓 Darkmode.js"></a>🌓 Darkmode.js</h2><p>其实<code>Darkmode.js</code>运用的也是 css 里面的一个特性叫<code>mix-blend-mode</code> — “CSS 属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合“。加上 Javascript 的辅助判断哪些页面上的元素需要黑化的，哪些是不需要黑化的。就会想我们之前那种做法，导致其他不需要黑化的元素，比如图片，受到影响导致颜色出现问题。</p><p>使用<code>Darkmode.js</code>非常简单，只要在脚本里面添加以下代码就可以马上加入一个插件，</p><pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/darkmode-js@1.5.5/lib/darkmode-js.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // 这些是这个插件的可配置项：  var options = {    bottom: &#39;32px&#39;, // 定位底部距离 - 默认: &#39;32px&#39;    right: &#39;32px&#39;, // 定位右边距离 - 默认: &#39;32px&#39;    left: &#39;unset&#39;, // 定位左边距离 - 默认: &#39;unset&#39;    time: &#39;0.5s&#39;, // 默认动画时间: &#39;0.3s&#39;    mixColor: &#39;#fff&#39;, // 需要改变的颜色 - 默认: &#39;#fff&#39;    backgroundColor: &#39;#fff&#39;, // 背景颜色 - 默认: &#39;#fff&#39;    buttonColorDark: &#39;#262728&#39;, // 黑暗模式下按钮颜色 - 默认: &#39;#100f2c&#39;    buttonColorLight: &#39;#fff&#39;, // 日间模式下按钮颜色 - 默认: &#39;#fff&#39;    saveInCookies: true, // 是否在cookie保存当前模式 - 默认: true,    label: &#39;🌓&#39;, // 切换模式按钮图标 - 默认: &#39;&#39;    autoMatchOsTheme: true, // 是否自动根据系统适应模式 - 默认: true  };  let darkmode = new Darkmode(options);  darkmode.showWidget();&lt;/script&gt;</code></pre><p>如果你不希望用这个插件的默认按钮，你可以在你的 JavaScript 代码中自主控制。我们可以通过<code>.toggle()</code>方法来切换模式，同时可以使用<code>.isActivated()</code>来检测是否已经进入黑暗模式。</p><pre><code class="js">const darkmode = new Darkmode();darkmode.toggle();console.log(darkmode.isActivated()); // 如果已经进入黑暗模式会返回 true</code></pre><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>filter: invert()</strong> — 可以把页面从白变黑，也可以从黑变白。</li><li><strong>filter: hue-rotate()</strong> — 用于改变你元素的颜色，同时或多或少保持原本相同的色系。</li><li><a href="https://darkmodejs.learn.uno/" target="_blank" rel="noopener"><strong>Darkmode.js</strong></a> — 瞬间实现黑暗模式。</li></ul><p><strong>Invert 方式黑暗模式：</strong><a href="http://tridiamond.me/frontend-tutorials/instantDarkMode/instantDark">预览实际效果</a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/instantDarkMode/instantDark" target="_blank" rel="noopener">GitHub 源码</a> ｜ 喜欢的童鞋 🌟star 一下谢谢<br><strong>Darkmode.js 黑暗模式：</strong><a href="http://tridiamond.me/frontend-tutorials/instantDarkMode/darkmodeJs">预览实际效果</a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/instantDarkMode/darkmodeJs" target="_blank" rel="noopener">GitHub 源码</a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="四、自定义列表符号"><a href="#四、自定义列表符号" class="headerlink" title="四、自定义列表符号"></a>四、自定义列表符号</h1><p><img src="https://img-blog.csdnimg.cn/20200402103145722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="自定义列表符号"><br><code>ul</code>，<code>li</code>的无序列表有默认的符号<code>·</code>，但是在很多情况下我们希望可以给这个符号加入自己的样式和颜色，甚至是换成自定义的符号。默认的符号我们是无法做任何的样式处理，而且默认的符号在 CSS 属性里面只有几个选择可以使用，很多情况下都是无法满足我们的设计。</p><p>其实自定义无序列表符号不难，我们只需要使用伪元素<code>::before</code>加<code>content</code>属性就可以实现。</p><p>在我这个例子里面我做了两个任务列表，一个是待处理任务，一个是已完成任务，各自给了不一样的列表符号和颜色。</p><p><strong>实现原理</strong></p><p>一、首先我们禁用了<code>ul</code>的默认符号样式<code>list-style: none</code></p><p>二、在<code>li</code>的<code>:before</code>伪元素上给予<code>content</code>内容值，待处理任务使用<code>🗹</code>，已完成任务<code>li.completed:before</code>使用<code>✔</code></p><p>三、为了展示效果更加好看我分别给了<code>li</code>和<code>li .completed</code>两个不同的颜色</p><p><strong>上代码看看是怎么实现的吧：</strong></p><p><strong>HTML</strong></p><pre><code class="html">&lt;div&gt;  &lt;h2&gt;待处理&lt;/h2&gt;  &lt;ul&gt;    &lt;li&gt;待办任务1&lt;/li&gt;    &lt;li&gt;待办任务2&lt;/li&gt;    &lt;li&gt;待办任务3&lt;/li&gt;    &lt;li&gt;待办任务4&lt;/li&gt;    &lt;li&gt;待办任务5&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;div&gt;  &lt;h2&gt;已完成&lt;/h2&gt;  &lt;ul&gt;    &lt;li class=&quot;completed&quot;&gt;完成任务1&lt;/li&gt;    &lt;li class=&quot;completed&quot;&gt;完成任务2&lt;/li&gt;    &lt;li class=&quot;completed&quot;&gt;完成任务3&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;</code></pre><p><strong>CSS</strong></p><pre><code class="css">ul {  list-style: none;  color: #fff;  font-size: 20px;  border: 3px solid #000;  padding: 1rem 2rem;  min-height: 200px;  margin: 15px 2rem 0 0;  background: #323232;  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);  border-radius: 8px;}li {  padding: 0.3rem 0;}li::before {  content: &#39;🗹 &#39;;  color: aqua;}li.completed::before {  content: &#39;✔ &#39;;  text-decoration: none;  color: greenyellow;}li.completed {  text-decoration: line-through;  color: #bdbdbd;}</code></pre><p><code>::before</code>和<code>::after</code>伪元素加<code>content</code>属性可以用来做很多特殊的效果，也是当代前端排版比较常用的“魔法”。说到伪元素的使用，我再给大家说一个比较常用的使用场景。</p><p>在管理后台或者是文章展示中，我们经常可以见到的“面包屑导航”也是用伪元素来插入每个目录中间的符号的。<br><img src="https://img-blog.csdnimg.cn/20200402224549741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="面包屑导航"><br><strong>实现逻辑</strong></p><p>一、这个导航含有 3 个<code>a</code>标签，首先给每个<code>a</code>标签加入一个伪元素<code>::after</code>，然后在<code>content</code>属性插入<code>/</code>符号。</p><p>二、然后使用<code>a:first-child</code>，这个伪类会选择到第一个<code>a</code>标签，然后使用<code>content</code>属性加入<code>»</code>符号。</p><p>三、因为我们第一步在每个<code>a</code>标签的后面插入了<code>/</code>符号, 所以我们需要在最后一个<code>a</code>标签清除掉。这里我们使用<code>:last-child</code>选择到最后一个<code>a</code>标签，然后用<code>content: &quot; &quot;</code>属性把伪元素的内容清楚掉。</p><p><strong>HTML</strong></p><pre><code class="html">&lt;div class=&quot;breadcrumb&quot;&gt;  &lt;a&gt;三钻&lt;/a&gt;  &lt;a&gt;前端&lt;/a&gt;  &lt;a&gt;教程&lt;/a&gt;&lt;/div&gt;</code></pre><p><strong>CSS</strong></p><pre><code class="css">.breadcrumb {  font-size: 1.6rem;  color: #fff;}.breadcrumb a:first-child {  color: #82fcfd;}.breadcrumb a:first-child::before {  content: &#39; » &#39;;}.breadcrumb a::after {  content: &#39; /&#39;;  color: #ef6eae;}.breadcrumb a:last-child::after {  content: &#39;&#39;;}</code></pre><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>::before | ::after</strong> — 伪元素用于向某些选择器添加特殊的效果。</li><li><strong>content</strong> — CSS 属性用于在元素的 ::before 和 ::after 伪元素中插入内容。使用 content 属性插入的内容都是匿名的可替换元素。</li><li><strong>:first-child</strong> — CSS 伪类表示在一组兄弟元素中的第一个元素。</li><li><strong>:last-child</strong> — CSS 伪类代表父元素的最后一个子元素。</li></ul><p><strong>自定义无序列表：</strong><a href="http://tridiamond.me/frontend-tutorials/customBulletPoint"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/customBulletPoint" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢<br><strong>面包屑导航：</strong><a href="http://tridiamond.me/frontend-tutorials/breadcrumbs"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/breadcrumbs" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="五、图片视差效果"><a href="#五、图片视差效果" class="headerlink" title="五、图片视差效果"></a>五、图片视差效果</h1><p><img src="https://img-blog.csdnimg.cn/20200403231604772.gif#pic_center" alt="图片视差效果"><br>这个超级炫酷的效果在官网中非常的受欢迎，这种效果可以给用户带来视觉冲击，也给我们的网站带来了活力。普通的网页图片会跟随着网页一起滑动，但是视觉差效果图就会固定在底部，只有图片所在的窗口上的元素会移动。</p><h2 id="仅使用-CSS"><a href="#仅使用-CSS" class="headerlink" title="仅使用 CSS"></a>仅使用 CSS</h2><p>对你没有看错，这个效果只需要用到 CSS 就能轻易的实现！我们只要使用一个 CSS 背景图的属性<code>background-attachment: fixed</code>，这个特性会把背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</p><p><strong>实现理论：</strong></p><p>一、在含有图片的元素中加入<code>background: url()</code>和<code>background-size: cover</code>（第二个属性适用于定义图片为封面，可以让图片大小自动适应，在很大的屏幕也会显示完整的图片）</p><p>二、然后附加固定背景图的属性<code>background-attachment: fixed</code></p><p>三、最后给这个元素加入一个高度<code>height: 100%</code>或者任意的高度<code>height: 400px</code></p><p>就那么简单哦！不用怀疑，马上上代码，大家都可以自己去试试哦！</p><p><strong>HTML</strong></p><pre><code class="html">&lt;div class=&quot;wrapper&quot;&gt;   &lt;div class=&quot;parallax-img&quot;&gt;&lt;/img&gt;   &lt;p&gt;这里填写一堆文字就可以了，尽量多一点哦&lt;/p&gt;&lt;/div&gt;</code></pre><p><strong>CSS</strong></p><pre><code class="css">.wrapper {  height: 100wh;}.parallax-img {  background-attachment: fixed;  background-position: center;  background-repeat: no-repeat;  background-size: cover;  height: 100%;  background-image: url(&#39;http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/7/thumb.jpg&#39;);}p {  font-size: 20px;  padding: 1.5rem 3rem;  min-height: 1000px; // 当你的文字内容不够，也能撑出足够的高度来看到效果，当然如果你文字足够多，就不需要了}</code></pre><p>如果想做到我动图里面一样的效果，或者想看是怎么实现的，可以查看下面总结里面的“<strong>预览实际效果</strong>”或者看“<strong>GitHub 源码</strong>”。</p><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>background-attachment: fixed</strong> — 把背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</li><li><strong>background-size: cover</strong> — 可以让图片大小自动适应，在很大的屏幕也会显示完整的图片。</li></ul><p><a href="http://tridiamond.me/frontend-tutorials/parallaxImages"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/parallaxImages" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h2 id="使用-CSS-JavaScript"><a href="#使用-CSS-JavaScript" class="headerlink" title="使用 CSS + JavaScript"></a>使用 CSS + JavaScript</h2><p><img src="https://img-blog.csdnimg.cn/20200405164618623.gif#pic_center" alt=""><br>有些童鞋可能没有被这个震撼到或者还是觉得不够刺激。那我们再来一个高级例子，上面的例子在滑动的时候图片是固定死的。如果我们加上 JavaScript 的助力，我们可以让窗口的图片缓慢的跟随这个页面滑动，使得效果更有动力和更有冲击感。</p><p><strong>实现理论</strong><br>首先讲一下排版，因为我们需要在我们滑动页面的时候使用 JavaScript 偏移图片，所以我们需要给图片一个 CSS 属性让我们可以让图片可以根据一个速度来往上或者往下移动。这个例子里面我们让所有图片包裹在一个<code>div</code>里面，<code>class</code>名为<code>block</code>。这个<code>div</code>给予相对定位属性<code>position: relative</code>，这个时候我们就可以在里面加入图片，然后让图片绝对定位<code>position: absolute</code>在这个<code>div</code>盒子里面。</p><p>但是图片是可能很大的，我们需要把图片不超出我们定义个盒子，所以我们的<code>div</code>同时也给予了<code>overflow: hidden</code>和一个高度<code>height: 100%</code>。这样图片超出<code>div</code>盒子就会被隐藏。</p><p>布局代码如下：</p><pre><code class="html">&lt;div class=&quot;block&quot;&gt;  &lt;img src=&quot;https://unsplash.it/1920/1920/?image=1005&quot; data-speed=&quot;-1&quot; class=&quot;img-parallax&quot; /&gt;  &lt;h2&gt;视差速度 -1&lt;/h2&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;  &lt;img src=&quot;https://unsplash.it/1920/1920/?image=1067&quot; data-speed=&quot;1&quot; class=&quot;img-parallax&quot; /&gt;  &lt;h2&gt;视差速度 1&lt;/h2&gt;&lt;/div&gt;</code></pre><pre><code class="css">html,body {  margin: 0;  padding: 0;  height: 100%;  width: 100%;  font-family: &#39;Amatic SC&#39;, cursive;}.block {  width: 100%;  height: 100%;  position: relative;  overflow: hidden;  font-size: 16px;}.block h2 {  position: relative;  display: block;  text-align: center;  margin: 0;  top: 50%;  transform: translateY(-50%);  font-size: 10vw;  color: white;  font-weight: 400;}.img-parallax {  width: 100vmax;  z-index: -1;  position: absolute;  top: 0;  left: 50%;  transform: translate(-50%, 0);  pointer-events: none;}</code></pre><p>实现这个布局，在你滑动的时候，图片是不会移动的。因为最后一步就是加入 JavaScript 的辅助，让图片活起来。</p><pre><code class="html">&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  // 循环获取每一个图片元素  $(&#39;.img-parallax&#39;).each(function () {    var img = $(this);    var imgParent = $(this).parent();    function parallaxImg() {      var speed = img.data(&#39;speed&#39;); // 获取每张图片设置了的偏移速度      var imgY = imgParent.offset().top; // 获取图片盒子所在的Y位置      var winY = $(this).scrollTop(); // 获取当前滑动到的位置      var winH = $(this).height(); // 获取浏览器窗口高度      var parentH = imgParent.innerHeight(); // 获取图片盒子的内高度      // 浏览器窗口底部的所在位置      var winBottom = winY + winH;      // 当前图片是否进入浏览器窗口      if (winBottom &gt; imgY &amp;&amp; winY &lt; imgY + parentH) {        // 运算图片需要开始移动的位置        var imgBottom = (winBottom - imgY) * speed;        // 运算出图片需要停止移动的位置        var imgTop = winH + parentH;        // 获取从开始移动到结束移动的%（根据开始与结束像素 + 移动速度）        var imgPercent = (imgBottom / imgTop) * 100 + (50 - speed * 50);      }      img.css({        top: imgPercent + &#39;%&#39;,        transform: &#39;translate(-50%, -&#39; + imgPercent + &#39;%)&#39;,      });    }    $(document).on({      scroll: function () {        parallaxImg();      },      ready: function () {        parallaxImg();      },    });  });&lt;/script&gt;</code></pre><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>position: relative</strong> — 相对定位。</li><li><strong>position: absolute</strong> — 绝对定位。</li><li><strong>overflow: hidden</strong> — 如果需要，内容将被剪裁以适合填充框。 不提供滚动条。</li></ul><p><a href="http://tridiamond.me/frontend-tutorials/advanceParallaxImages"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/advanceParallaxImages" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="六、裁剪图像的动画"><a href="#六、裁剪图像的动画" class="headerlink" title="六、裁剪图像的动画"></a>六、裁剪图像的动画</h1><p><img src="https://img-blog.csdnimg.cn/2020040600130848.gif#pic_center" alt="裁剪图像的动画"><br>在有 CSS3 之前裁剪图片实现也是颇有难度的。现在我们有了两个非常方便简单的 CSS3 属性可以实现裁剪，那就是<code>object-fit</code>和<code>object-position</code>, 这两个属性可以让我们改变图片的大小，但是不影响图片的长宽比。</p><p>当然我们可以使用图片处理工具或者使用 JavaScript 等插件来实现图片裁剪功能。但是因为有了 CSS3 的属性，我们不只可以裁剪，我们还可以用裁剪的属性来做图片的动态效果。</p><p>为了让我们的例子更加简单，我们这里使用了<code>&lt;input type=&quot;checkbox&quot;&gt;</code>复选框元素，这样我们就可以使用<code>:checked</code>的伪类来触发启动效果。所以在例子里面我们完全不需要 JavaScript 的协助。</p><p><strong>实现原理：</strong></p><p>一、首先给予图片一个宽高<code>height: 1080px</code>，<code>width: 1920px</code>。</p><p>二、然后用 CSS 选择器，锁定当<code>input</code>被选中后<code>img</code>标签的样式变化。当被选中时，给图片设定一个新的宽高，这里我们给宽高各自 500 像素：<code>width: 500px</code>，<code>height: 500px</code>。</p><p>三、然后我们加上了过渡效果和时间让图片改变宽高时有动画过渡效果：<code>transition: width 2s, height 4s;</code>。</p><p>四、最后加上<code>object-fit: cover</code>和<code>object-position: left-top</code>这两个属性来保持图片的宽高比例，这样就大功告成了！</p><p><strong>我们来看看完成的代码：</strong></p><pre><code class="html">勾选裁剪图片&lt;input type=&quot;checkbox&quot; /&gt;&lt;br /&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020032122230564.png&quot; alt=&quot;Random&quot; /&gt;</code></pre><pre><code class="css">input {  transform: scale(1.5); /* 只是用来放大复选框大小 */  margin: 10px 5px;  color: #fff;}img {  width: 1920px;  height: 1080px;  transition: 0s;}/* css选择器锁定复选框被选中时的状态 */input:checked + br + img {  width: 500px;  height: 500px;  object-fit: cover;  object-position: left-top;  transition: width 2s, height 4s;}</code></pre><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>object-fit</strong> — CSS 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</li><li><strong>object-position</strong> — 用来切换被替换元素的内容对象在元素框内的对齐方式。</li><li><strong>transition</strong> — 过渡可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。</li></ul><p><a href="http://tridiamond.me/frontend-tutorials/cropImage"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/cropImage" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="七、混合模式（Blend）"><a href="#七、混合模式（Blend）" class="headerlink" title="七、混合模式（Blend）"></a>七、混合模式（Blend）</h1><p><img src="https://img-blog.csdnimg.cn/20200406104716527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="混合模式"><br>如果有使用过 Photoshop 的同学对<code>blend</code>混合模式应该是非常熟悉了，我们都知道混合模式是非常强大，也是 p 图时非常常用的一个功能。但是你们有没有想象过可以在浏览器的 CSS 中直接使用呢？对我们不需要设计师给我们做图，我们前端也可以实现混合模式了。</p><p>在 CSS 中我们不只可以对<code>background</code>背景加入混合模式，我们可以对任何一个元素的自带背景加入混合模式，让你可以做出很多之前没有想过的效果和排版。</p><p>往一个元素加入混合模式，我们只需要使用到一个 CSS 属性<code>mix-blend-mode</code>即可。</p><p><strong>简单实现原理：</strong></p><p>首先我们只需要加一个 h1 标题标签</p><pre><code class="html">&lt;h1&gt;混合模式：颜色减淡&lt;/h1&gt;</code></pre><p>然后我们给<code>h1</code>标签加入<code>mix-blend-mode</code>中的颜色减弱模式<code>color-dodge</code>，但是要注意的是我们需要给<code>body</code>和<code>html</code>加入背景颜色<code>background: white</code>，要不你会发现这个效果会无效。因为<code>h1</code>我们没有给颜色，会自动往上级继承，并且混合模式是针对背景颜色的过滤，所以 body 和 html 需要有背景颜色才行。</p><pre><code class="css">h1 {  mix-blend-mode: color-dodge;  font-family: yahei;  font-size: 5rem;  text-align: center;  margin: 0;  padding: 20vh 200px;  color: #d1956c;}html,body {  margin: 0;  background-color: white;}body {  background-image: url(https://images.unsplash.com/photo-1505567745926-ba89000d255a?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=3302&amp;q=80);  background-repeat: no-repeat;  background-size: cover;  min-height: 100vh;  overflow: hidden;}</code></pre><p>换换背景图和<code>h1</code>标签的字体颜色就可以弄出各种不同的特效了。</p><p><img src="https://img-blog.csdnimg.cn/20200406104058843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="颜色减弱"><br><img src="https://img-blog.csdnimg.cn/20200406103844679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="颜色减弱"></p><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>mix-blend-mode</strong> — CSS 属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。</li></ul><p><a href="http://tridiamond.me/frontend-tutorials/blendMode"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/blendMode" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="八、瀑布流布局"><a href="#八、瀑布流布局" class="headerlink" title="八、瀑布流布局"></a>八、瀑布流布局</h1><p><img src="https://img-blog.csdnimg.cn/20200406134310340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70#pic_center" alt="瀑布流布局"></p><p>CSS <code>Grid</code>和<code>Flexbox</code>让我们可以更简便，更容易和更快的实现各式各样的响应布局，并且让我们快捷方便的在布局中实现横向剧中和竖向剧中。但是回想一下以前是颇为困难的。</p><p>虽然这些新出的布局方式可以让我们解决很多以前的布局难题，但是像瀑布流布局这种，就无法用它们简单来实现了。因为瀑布流一般来说都是宽度一致，但是高度是根据图片自适应的。并且图片的位置也是根据在上方图片的位置而定的。</p><p>其实最好实现瀑布流布局的办法就是用 CSS 的列属性套件，这套属性大多数都是用于排版杂志中的文本列。但是用于布局瀑布流也是特别实用哦。因为以前需要实现瀑布流，就必须有 JavaScript 的辅助来计算图片高度然后决定每张图片的定位和位置，所以现在有了列属性就可以使用纯 CSS 实现了。</p><p><strong>实现原理：</strong></p><p>实现这个布局，首选我们需要把所有的内容先包裹在一个<code>div</code>元素里面，然后给这个元素<code>column-width</code>和<code>column-gap</code>属性。</p><p>然后，为了防止任何元素被分割到两个列之间，将<code>column-break-inside: avoid</code>添加到各个元素中。</p><p>神奇的效果就完美实现了，零 JavaScript。</p><p>我们来看看代码：</p><pre><code class="html">&lt;div class=&quot;columns&quot;&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?city&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?night&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?developer&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?building&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?water&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?coding&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?stars&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?forest&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?girls&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;  &lt;figure&gt;    &lt;img src=&quot;https://source.unsplash.com/random?working&quot; alt=&quot;&quot; /&gt;  &lt;/figure&gt;&lt;/div&gt;</code></pre><pre><code class="css">.columns {  column-width: 320px;  column-gap: 15px;  width: 90%;  max-width: 1100px;  margin: 50px auto;}.columns figure {  display: inline-block;  box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4);  column-break-inside: avoid;  border-radius: 8px;}.columns figure img {  width: 100%;  height: auto;  margin-bottom: 15px;  border-radius: 8px;}</code></pre><blockquote><p>🌟<strong>知识总结</strong></p><ul><li><strong>column-width</strong> — CSS 属性建议一个最佳列宽。 列宽是在添加另一列之前列将成为最大宽度。</li><li><strong>column-width</strong> — 该 CSS 属性用来设置元素列之间的间隔 (gutter) 大小。</li><li><strong>column-break-inside</strong> — 设置或检索对象内部是否断。</li></ul><p><a href="http://tridiamond.me/frontend-tutorials/waterfall"><strong>预览实际效果</strong></a> ｜ <a href="https://github.com/TriDiamond/frontend-tutorials/tree/master/waterfall" target="_blank" rel="noopener"><strong>GitHub 源码</strong></a> ｜ 喜欢的童鞋 🌟star 一下谢谢</p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/20200406152836460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="总结"><br>我希望这 8 个前端小技巧和特效对大家有帮助，或多或少有吸收一点新的前端知识。这篇文章提到的内容，其实很多都是值得深挖和学习的。有一些例子我做的比较简单，但是其实是有无限的可能性。喜欢前端的童鞋们，让我们继续在前端领域中一起深挖，让我们的热爱无限的燃烧起来吧！</p><hr><p>在最后我想给大家讲一下我对前端的热爱和态度。</p><p>回想前端这几年，发展真的是突飞猛进，从前端排版，HTML5+CSS3 做 H5 页面，到前端组件化，各种 UI 框架满天飞。</p><p>一开始我随着热潮用起了 UI 框架，起初觉得特别方便，来一个新的项目就直接上一个 UI 框架，研发速度也非常快。但是久而久之就觉得前端开发变成了处理数据，对接接口，实现交互。</p><p>某天在阅览国外的一些前端设计和框架的时候，我突然发现国内多数的前端开发者都不再怎么使用 CSS3 做出一些很好玩的布局和特效了。现在市面上的系统和页面都是千篇一律，普遍都是用一些知名的 UI 框架搭建系统和 APP，基本自己动手去排版已经少之又少。前端已不再是以前的前端，缺少了灵魂。</p><p>但是我们回想一下，我们刚刚开始学习前端的时候，让我们最有成就感，觉得前端特别有意思的那种感觉。就是那种让我们觉得神乎奇迹，不可思议的布局，特效和交互。那种感觉自己成功实现了很优美，很炫酷的页面和特效的感觉，让我们越做越来劲，越做越是兴奋。</p><p>但是在某些公司，研发部都是要求快速开发，UI 设计部门也是受到时间的控制和限制，所以逐步走进了 UI 框架的限制之中。都是围绕这一些 UI 框架来设计和开发系统和应用。</p><p>作为一名热爱前端的开发者，我还是坚持在绝大多数的项目中，自己排版和实现页面交互特效。然后使用 UI 框架作为辅助，主要是用来减轻一些小组件和常用组建的快速实现。（可以说我是比较追求完美和外貌协会的程序员 😂）</p>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
            <tag> CSS Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给想学和在学编程的你们，学习编程的7个好处</title>
      <link href="/2020/03/29/notes/benefits-for-learning-programming.html"/>
      <url>/2020/03/29/notes/benefits-for-learning-programming.html</url>
      
        <content type="html"><![CDATA[<p>你们有没有这种经历？亲戚或者爱人甚至是不做技术的朋友，看到我们屏幕上的小括号<code>{}</code>，大括号<code>[]</code>，还有一大堆的技术英文单词<code>private</code>，<code>public</code>，<code>function</code>等等，都会惊叹一句“<strong>你写的是什么呀？太可怕了，全是英文看不懂。</strong>”或者“<strong>做个程序员是不是需要英语很好的呀？太难了！</strong>” 其实当真正学习编程和做起程序员来一切并没有那么的可怕，也并不需要英语有多厉害。不信的小伙伴可以问问身边大多数的程序员，问问他们刚开始学编程的时候英语是不是很好，估计得到的大部分答案都是：“没有哈，不是的哈”。</p><p>当然，如果你英语比较好，在编程的路上确实是会给你带来一定的优势。我们可以这么去想，会英语的看代码就等同于会是在看一本书一样，函数名，方法名其实都在描述这个代码是在做什么的。自然理解起来的时候就不需要很费劲了。加上学习新的技术和原汁原味的技术时，都会需要看国外的文章和文档，这些基本都是英文。<strong>但是不会英语也一样可以学好编程，也一样可以成为一名优秀的程序员。甚至在学编程的路上，你的英语也会有所提升。</strong></p><p>==其实选择学编程是能改变人生的==。可能起初很多人学编程，报了一个编程培训班，为了就是能拿到更高的工资或者有更好的工作环境。最后坚持着坚持着，最后会发现编程还会给我们带来很多个人能力和技能上的提升。</p><hr><h1 id="「一」什么是编程？"><a href="#「一」什么是编程？" class="headerlink" title="「一」什么是编程？"></a>「一」什么是编程？</h1><p><img src="https://img-blog.csdnimg.cn/20200327115516168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70#pic_center" alt="什么是编程？"></p><p>想开始学习编程或者坚持学习编程，我们首先要知道什么是编程？做编程的开发者是做什么的？这个行业是否合适自己？— 做为程序员，开发者和编程工程师，对外行人来说我们跟 TA 们说我们这些职称，基本 TA 们脑海里都会出现一个在修电脑或者修手机的我们。还会来一句“噢噢，做 IT 的呀？改天过来帮我看看我的电脑，开不了机了。”</p><p><strong>在 TA 们的脑海里就出现了这么一个画面 🤔：</strong></p><center><img src="https://img-blog.csdnimg.cn/20200327114633939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" width="40%" alt="在TA们的脑海里就出现了这么一个画面" /></center><h2 id="程序员是什么？"><a href="#程序员是什么？" class="headerlink" title="程序员是什么？"></a>程序员是什么？</h2><p>我们用一个能让大家都懂的方式解说程序员做的编程工作到底是什么：</p><blockquote><p>如果现在我们需要一把剑，那我们就会找造剑的工匠。 同等现在我们要做一个手机 APP，一个网页系统，一个软件或者一个电脑工具，打造这些的工匠就是程序员。</p><hr><p>🌟<strong>简单的说“程序员和开发者就是打造软件或者互联网产品的工匠，我们的材料就是全英文的<code>代码</code>，我们的工具就是<code>代码编辑器（IDE）</code>”</strong>。</p></blockquote><p>这样说外行人应该就懂程序员，开发者，软件工程师是个什么鬼玩意了。</p><hr><h2 id="前端和后端又是什么？"><a href="#前端和后端又是什么？" class="headerlink" title="前端和后端又是什么？"></a>前端和后端又是什么？</h2><p>好奇的人还会问，”听说开发还分后端和前端，那<code>后端</code>和<code>前端</code>又有区别呢？” — 好问题呀童鞋，这个真的让人难以解说了。不过不用怕，给大家两例子让 0 技术基础的 TA 们都能听的明明白白。</p><p><strong>后端解说例子：</strong></p><blockquote><p><strong>后端写的程序就是一个货物仓库中工作人员的指挥部</strong>。来仓库找材料的人需要 10 万个“外科口罩”。这个时候指挥部先找到这个口罩在仓库的具体坐标，然后会发出指令告诉仓库工作人员去到某一个地区的货架，第二排找到这口罩，最后搬过来给到需求方。</p><hr><p><strong>转化为技术专业名词：</strong></p><ul><li>找货物的人 — 就是<strong>调用后端接口</strong>拿数据的一方</li><li>仓库指挥部 — 后端编写的<strong>程序</strong></li><li>仓库 — 就是保存资料信息的<strong>数据库</strong></li><li>仓库的货物 — 就是数据库里面的<strong>数据</strong></li></ul></blockquote><p><strong>前端解说例子：</strong></p><blockquote><p><strong>如果后端操控存放货物的仓库，那前端就是建筑师</strong>，前端主要的工作是建立店铺和装修店铺，然后从仓库获取货物到店铺中展示。一个店铺中货物必须分类摆放，有条理，好看才会有人买。所以前端还会规整货物，让货物分类摆放，同时让客户容易找到还好看的舒服感，自然就会有更多的客人来店购物。</p><hr><p><strong>转化为技术专业名词：</strong></p><ul><li>店铺 — 就是<strong>前端打造的页面</strong></li><li>建立店铺和装修的材料 — 就是前端页面<strong>排版</strong></li><li>店铺中的货物 — 就是后端给予前端的<strong>数据</strong></li><li>取货 — 就是前端请求后端获取<strong>数据</strong></li></ul></blockquote><hr><p>还有比较常见的两个方向，前端和后端。当然编程还有很多方向，比如“算法工程师”，“运维工程师”，“测试工程师” 等等。这里我就不一一细说了。有需要了解其他的可以在评论区给我留言。</p><p>我们需要了解清楚什么是编程，开发者们做的是什么。程序员用编程打造软件产品的工匠，给人类带来更便捷的工具与平台。让我们可以通过手机，电脑加互联网来自动化，系统化，智能化的完成我们的工作或者沟通。甚至可以高效提高很多行业中工作的效率，解决很多繁杂的操作和任务。还可以给我们带来信息快速传播和展示的作用。每个程序员都有一个梦想：“用代码改变生活，用代码改变世界！”</p><hr><h1 id="「二」学编程的好处"><a href="#「二」学编程的好处" class="headerlink" title="「二」学编程的好处"></a>「二」学编程的好处</h1><p><img src="https://img-blog.csdnimg.cn/20200328101632907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70#pic_center" alt="学编程的好处"><br>学习编程其实没有想象中那么难，但是也并非一条容易的道路。在学习编程的过程中最困难的就是动力和坚持。一开始学习的时候我们会很感兴趣，每做出一个小功能后会感到非常有成就感。可是当我们越学越多，越学越难之后我们会开始觉得枯燥无味。一个问题或者一个难题可能都要好几个小时，甚至是一天两天才得以解决。所以不论是我们在学习之前还是在学习中工作中，我们都要有发自内心的热爱和动力。</p><p>所以我们需要找到我们学习编程的好处，我们能得到什么，能改变什么。这样我们的毅力和动力才能得以持续维持。我希望通过接下来的分析，能给到感兴趣但是也不是很有动力的童鞋开始学习编程，在学习编程中有点迷茫的童鞋更能坚持下来，更加热爱这一条道路！</p><hr><h2 id="1-拥有把想法转化成应用的魔法"><a href="#1-拥有把想法转化成应用的魔法" class="headerlink" title="1. 拥有把想法转化成应用的魔法"></a>1. 拥有把想法转化成应用的魔法</h2><p><img src="https://img-blog.csdnimg.cn/2020032811170475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="拥有把想法转化成应用的魔法"><br>做为一个程序员，最有成就感的一件事情就是能把一些想法，一些有趣的点子通过编程把它们转化为应用。一个可以操作、可以体验和可以帮助很多人的应用。但是如果我们不懂编程，我们就只能找技术来帮助你实现。但是开发成本太昂贵了，最终就选择放弃。</p><p>估计大家在这个互联网时代中，每天日复一日的生活中，都会有那么一瞬间觉得 “有那么一个 APP，那么一个平台，我们做某一件事就会方便多少，就会简单多少” 。但是我们不懂编程，不懂技术，无法去实现，所以到了最后我们就会与这个很好的想法擦肩而过了。也许当过了几个月后，就会发现有人做出了这么个应用，和你当时想的是一摸一样的，就会开始觉得，“诶，如果我能自己做，现在看到的这个应用就是写上了我的签名，在改变大家生活和人生的人就是我了”。</p><p>在现实中，如果要一个想法落实到生产出应用也绝非易事。人在大脑构思出来的想法，要表达出来给到产品经理整理逻辑，转化成原型。然后通过原型还需要 UI 设计师转化成设计稿，最终到开发者手上再理解一才能真正开始研发。但是多少想法在这个过程中被人与人之间的沟通，传达，理解所被丢失的细节呢？所以最终做出来的产品往往不是完完全全和一开始构思的一摸一样。</p><p>其实很多开发者都是在这个研发流水线中的一员，研发部没有了产品，没有 UI 设计，前端就无法排版，后端就无法研发。不知道大家有没有留意大厂或者是国外的开发者。很多前端都是懂 UI，懂设计理念，甚至是两者兼备的。然后后端都是懂前端，起码有前端知识的基础。为什么呢？因为一个想法经过越少的人，就会丢失越少的信息。这样做出来的产品才能与当初想的越贴切。当然，如果研发中心的每个部门的人都是牛人，必然能打造很好的产品的。但是中小型的公司的人员能力参差不齐，在我以前待过的中小型公司的老板都是天天跟着产品，设计和开发的屁股盯着。就怕最终产品走了样。</p><p>俗话说的好“如果你想心想事成，最好的方法是自力更生”。也是因为这样我也走上了全栈开发之路。产品，设计，前端，后端和运维都专研了一遍。</p><p>当然做为专研一个技术领域的开发人员也能做出很好的产品。比如说博客，个人网站，excel 处理程序，春节抢票工具等等。多少这些提高我们工作和生活的产品都是开发者自己在日常生活或者工作中，想避免一些繁杂的事情做出来的工具或者应用。</p><p>但是如果我们不懂编程，就只能依赖于别人。<strong><code>“因为懂编程，我们的想象力可以是我们的创造力”</code></strong></p><hr><h2 id="2-拥有强大的学习能力"><a href="#2-拥有强大的学习能力" class="headerlink" title="2. 拥有强大的学习能力"></a>2. 拥有强大的学习能力</h2><p><img src="https://img-blog.csdnimg.cn/20200328120210359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="拥有强大的学习能力"><br>编程的世界是一个高速发展和变化的环境，也与星空一样知识是无边无际的。今日的编程实现方式与 5 年前的来相比，已经是截然不同了。每天每个编程的语言与 TA 们的框架都在升级迭代中。</p><p>我们无法学会所有编程语言或者技术栈，不过我们是可以在某几个编程领域中发光发亮。只要我们坚持，专研，深度学习一门技术，我们必定会变成这一方面的专家。</p><p>在编程的世界里，我们会找到很多可以学习和成长的空间。无边无际的知识海洋，就算一门语言我们学到了 TA 的巅峰境界，我们还可以去突破 TA，或者选择再学习多一门语言来提升我们自己的研发能力。所以在这种高速发展的技术领域中，我们的大脑的会被各种技术的知识开阔我们的很多思维。</p><p><strong>给大家讲一个我的经历：</strong></p><p>我入行编程事业的时候没有现在的前后端分离，后端是需要和前端混编的，而且一开始在中小型企业也没有完善的产品部，设计部，研发部。所以对于前端的知识还是需要懂的。我进入的第一家公司，没有产品经理，没有 UI 设计师，没有前端工程师，研发部就我一个人。一进入公司项目老大就跟我说，要我一个月做一个物流管理系统（ERP），并且要实现：商品管理，订单管理，进销存管理。然后商品和订单，需要与淘宝，天猫和京东对接上，可以实时同步。从产品的需求整理，沟通到设计和研发都是我一个人在弄。</p><p>年少轻狂的我，毕竟是交代下来的工作，那就是一个字“干”！从不懂什么叫 ERP，到了解商品管理，多规格 SKU，订单状态流，入库出库单到学会对接第三方平台订单。一路过来有无数个不眠夜，无数个在写着写着代码就昏睡过去几分钟的经历。不止需要学懂业务，还需要自己排版，自己提升自己前端的能力。这个过程说长不长，说短不短，一个月我独立完成了商品体系，订单体系，进销存体系，订单同步完成了 80%左右。（后面公司招到了更多的开发，最后与 4 个开发者一起完成了这个系统。随后还做了客户管理系统 — CRM）</p><p>说实话这个过程我有无数遍想过放弃和辞职，但是我出去又有什么本事去更好的公司呢？我当时的技术能力一文不值，去一个好的公司根本就是妄想。咬咬牙齿就继续坚持下来了。</p><p>一点都不夸张的说，当时基本每天上班 18-20 个小时，眯眼就大概 2-4 个小时。但是事后，我发现自己学习能力，适应能力，抗压能力各方面都得到了飞跃性的提升。在我往后的技术生涯中有了很多帮助。当然我并不建议大家都进入这种玩命的公司来快速学习和成长。毕竟当时的我是被逼无奈。</p><p>在我的这段经历出来后，我感觉自己脱胎换骨，对于技术的热爱半点不减，反而发现不停的学习和成长非常重要。过了那么多年后还在学习和成长的路上。</p><p><code>不知不觉在编程的领域中，会发现我们的学习能力会得到不断的提升，因为我们每天都在学习和成长。而我们的未来还有无边无际的知识海洋在等着我们。</code></p><hr><h2 id="3-编程提升逻辑思维和分析的能力"><a href="#3-编程提升逻辑思维和分析的能力" class="headerlink" title="3. 编程提升逻辑思维和分析的能力"></a>3. 编程提升逻辑思维和分析的能力</h2><p><img src="https://img-blog.csdnimg.cn/20200329143602445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70#pic_center" alt="编程提升逻辑思维和分析的能力"><br>编程就是用逻辑思考能力把问题分解成一个个小问题，逐个突破。也是用分析能力把功能和任务分解成一个个小任务，然后小步快跑的去快速完成。</p><h3 id="逻辑思维能力"><a href="#逻辑思维能力" class="headerlink" title="逻辑思维能力"></a>逻辑思维能力</h3><p>在编程中我们会遇到很多问题，并且需要我们一个个的去解决。解决困难，解决问题是做为一个开发者必备的技能。大到技术架构，解决业务场景带来的难度和逻辑复杂度，小到解决系统中的问题和缺陷，使用逻辑思维去排查和修复漏洞。</p><p>在每天的工作中开发者都是会面对各种各样的问题和困难，长年累月每一个开发者都会养成解决问题的能手。渐渐的我们会有各式各样解决问题的办法。一个我们经常用的口诀“先思考，后百度，再求助”。（个人推荐用 Google，更容易找到精准的答案）</p><p>也是因为日常的不断锻炼和思考，让我养成一种逻辑思维来解决问题。每一个问题都会建立一套一套的逻辑思维方式和方法来解决。比如系统中的一个问题出现了，一个资深的开发者，瞬间就可以定位到问题并且给出解决方案。其中最重要的一个点是因为资深开发者长年累月的经验，还有就是熟悉解决问题的排查方法，一套高效快速的方法。</p><h3 id="分析能力"><a href="#分析能力" class="headerlink" title="分析能力"></a>分析能力</h3><p>作为一名开发者，每天都需要分析需求，功能，难题等等。分析、整理和思考都是每日的家常便饭。</p><p>当一个需求到手的时候，开发者需要去分析里面的功能，把功能分解成一个个小块来进行设计，给出对应的实现方案。同时也需要我们去分析里面新增，修改，优化的功能对现有架构，功能和体系存在的影响和难度。最后定制出解决方案或者实现方案。</p><p>除了需要分析需求，我们还需要去分析每个功能或者业务的流程和逻辑。比如一个系统中的登陆流程大概就是：<br><img src="https://img-blog.csdnimg.cn/20200329105421325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="登陆流程"><br>经过编程的长期锻炼，我们的思维会发生改变，遇到每一件事情或者事物，我们都会解刨分析。比如讲到车，我们首先会把车分解成一块块来分析，引擎，轮轴，车胎和油箱等等，然后深度分析每一部分的作用和逻辑，从而明白整体车是怎么运作和构建的。</p><p><code>编程的过程中，会培养我们的逻辑思考能力和分析能力。渐渐的会让我们成为一名先通过深度分析，然后用逻辑思维解决问题的大师。</code></p><hr><h2 id="4-用自动化程序为我们干活"><a href="#4-用自动化程序为我们干活" class="headerlink" title="4. 用自动化程序为我们干活"></a>4. 用自动化程序为我们干活</h2><p><img src="https://img-blog.csdnimg.cn/20200329114245175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70#pic_center" alt="用自动化为我们干活"><br>日常生活中，我们有很多重复的工作，极度的枯燥乏味。但是我们幻想一下，如果编写一个程序可以帮我们自动化的处理掉这些工作，是不是很舒服？这样我们就会有更多的时间思考，或者做更多有意义的事情。</p><p>自动化，智能化都是现在科技高速发展时代经常听到的热搜词。目前给我们带来很多生活中方便的应用、系统和工具都是怎么来的呢？其实都是程序员用代码编写出来的。</p><p>支付宝、微信、钉钉等这些应用大家都很熟悉吧，基本每天都会用到。其实里面帮我们做了很多繁琐的事情，比如说支付宝帮我们记账，分析出每月我们的支出。微信的语音功能可以自动帮我们转换成文字，让我们不方便打字，或者懒得打字的时候，录一段语音，点个按钮就转换成文字，还自动给我们加上标点符号。钉钉为我们引入了自动蓝牙打卡，不需要天天排队打卡，每个月还会自动生成考勤异常情况，分析出某个人某天缺了打卡或者某天有缺勤需要补一个调休。</p><p>这些都是编程为我们日常生活中带来的方便和便捷。让一些需要我们坐下来花时间处理的繁杂事情变得更自动化、简单化和智能化。如果没有支付宝，每天我们还需要带着现金出门，不够现金了，还需要去一趟银行取钱。如果没有微信，我们可能还需要写信，然后出去邮寄才能与远方的朋友联系聊天。如果没有钉钉，每个月考勤情况，还需要我们去人工计算核对时间和缺勤情况。</p><p><code>学会编程不止可以编写改变世界的代码，还能为我们自己日常工作或者生活中编写工具来节省时间</code>。如果我们学会了 Python 编写 Excel 脚本来处理表格，自动填充和获取信息。根据我们每天在电脑的工作行为用脚捕捉写成日报表，甚至自动帮我们提交。自然就可以多出很多的时间来学习和做其他有意义的事情。</p><hr><h2 id="5-拥有高薪的职业"><a href="#5-拥有高薪的职业" class="headerlink" title="5. 拥有高薪的职业"></a>5. 拥有高薪的职业</h2><p><img src="https://img-blog.csdnimg.cn/20200329114342744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="高薪职业"><br>技术行业的薪资相对比其他行业的平均薪资都会高一些。其实每一行都可以到达很高的薪资，每一行都有每一行的辛苦。但是一个永恒不变的定律，一分付出就有多一分收获。编程也是因为有难度，每天都是辛苦的脑力活，所以才会薪资高。</p><p>其实程序员工资高也是因为当前是互联网和科技高速发展的时代，所以编程岗位也还处于非常短缺的状态。加上技术一直在发展，技术和互联网相对比其他行业还是属于一个成长期。很多新型的技术和语言每日每夜都在更新迭代。技术行业的岗位也是每年都在增加。从几年前的前端后端，到现在的人工智能开发，甚至到未来的机器人开发。</p><p>技术行业的薪资体系，目前来看，我是觉得不是很标准的。这几年来面试的过程中，很多应聘者对自己能力的评估和价值都是有偏差的。但是我觉得相对其他行业，技术活都是凭能力说话，凭能力换来对等的报酬的。只要自己的能力强，技术的知识深度够，实战能力够硬。月入过万都不是梦。</p><p><code>如果你们热爱高效的工作和无限的自我提升空间，大概你们会很喜欢和技术开发人员一起工作。</code>我们是一群为了产出更有的程序而坚持提升自己，为了产出更好的产品而马不停蹄的提升自己的程序和代码。在这个领域中，会让你们大开眼界，扩大自己的思维瓶颈。每日都会发现各式各样的新鲜事物。<code>能力的提升都会给我们带来对等的薪资提升，是一个越努力越赚钱的行业！</code></p><hr><h2 id="6-可以是一个有趣的业余爱好"><a href="#6-可以是一个有趣的业余爱好" class="headerlink" title="6. 可以是一个有趣的业余爱好"></a>6. 可以是一个有趣的业余爱好</h2><p><img src="https://img-blog.csdnimg.cn/20200329114815410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70#pic_center" alt="有趣的业余爱好"><br>学习编程成为一名开发者，不一定是要作为你朝九晚五的一份工作。可以把编程当成一个我们热爱的爱好，甚至是一份副业。</p><p>在我读大学的时候，我并不是一名读计算机专业的学生，当时的我特别热爱玩游戏，也特别喜欢写攻略。有一个公会里面的老大就跟我说，为什么不自己做一个攻略网站或者博客，还可以顺便赚一下广告费。就是这样我开始了自学编程，手把手搭建起自己的网站和博客，从此爱上了编程。</p><p>大学期间我还接过很多做网站的外包，做过无数个网站和博客的主题开发。也赚了一些游戏经费和学习经费。到了后面我开始研究开游戏私服，自学了一些游戏开发，开启了游戏私服。</p><p>这个过程中，我把编程当成了自己的一个业余爱好，也没有想过今天的我居然成为一名朝九晚五的程序员。回过头想想，编程给我带来了无比的快乐与成就感。作为一名开发者，可以让我们的想象力自由飞翔，实现我们所想，唯一需要的就是我们懂得编写代码， 代码，就能打造出我们心中所想的东西。无论你现在是想写一个网站介绍你自己，写一个博客记录你学习路上的种种，还是写一个无比有趣的小游戏。编程都可以如你所愿！</p><p><code>编程对于任何人都可以是一个有趣的业余爱好，没有门槛。任何人只要有一台电脑，能上网，就可以开始学编程。编程是不受任何的限制。只要你愿意学，有兴趣，有毅力，你都能学会。</code></p><hr><h2 id="7-充满活力及友善的社区"><a href="#7-充满活力及友善的社区" class="headerlink" title="7. 充满活力及友善的社区"></a>7. 充满活力及友善的社区</h2><p><img src="https://img-blog.csdnimg.cn/20200329153128613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="充满活力及友善的社区"><br>程序员是我见过最有趣，最可爱，相处起来最轻松舒服的一群人。程序员之间没有过多的勾心斗角，像其他行业团队里面那么多的宫斗剧上演。在我待过的团队中，比较多的都是热爱学习，热爱生活，热爱代码的一群热血青年。</p><p>当然，凡事无绝对，都是有好有坏，也会有有一些比较让人恶心的程序员就希望自己每天工作中舒舒服服、一问三不知和一叫三不做的人。好在这些人还是占少数的，相对一二线的城市和有些规模的公司工作，普遍团队中的程序员都是比较好相处，并且在工作中会让我们非常开心有趣。</p><p>每一个语言或者框架，都有一群充满热情和活力的社区等着你的到来。比如 CSDN，掘金，Segmentfault，Stackoverflow，GitHub 等等这些大型的技术社区有很多的热心和热爱技术的开发在维护着这个充满热情的编程世界。如果我们需要帮助，有无数的手会伸出来援助于我们。</p><p><code>在学习编程和技术开发工作中，作为一名程序员，我们并不孤单。我们都是一个团体在一起努力，一起奋斗，一起并肩作战。</code>还有网上的各路英雄好汉在江湖中奔跑着，随时可以认识到其他的开发者与你共同进步，一起终生学习，热爱编程，热爱生活！</p><hr><h1 id="「终」总结"><a href="#「终」总结" class="headerlink" title="「终」总结"></a>「终」总结</h1><p><img src="https://img-blog.csdnimg.cn/20200329163909438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt="总结"><br>这周我又写了一篇上万字的博文，给想学和在学编程的童鞋们打打气，也把我自己在编程事业中的感触分享给大家。最后我想大声的跟大家说：<code>“对！无论我们当前是多大岁数，不懂英文也好，不懂电脑也好，编程都值得我们花时间和精力去学”。</code></p><p>在这个技术和科技高速发展的时代，不懂编程就像古代中的文盲一样。你永远不知道你是否喜欢一样东西，直到你尝试它。所以对编程有兴趣的，想学编程的，现在就打开你们的电脑，开始投身到技术的海洋吧！在学习编程的你们，坚持再坚持，只要你努力，你坚持，就必定会成功！所有的付出都会得到收获，所有的艰辛都会换来未来的幸福，越努力越幸运，越努力越赚钱。</p><p>在编程的路上，有无限的可能，也有无限的空间，只要你热爱它，它也会相应的回报努力的我们！让我们一起终生学习，用代码改变生活，改变世界！</p>]]></content>
      
      
      <categories>
          
          <category> NOTES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programmer </tag>
            
            <tag> Better Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用“易于改编”原则, 提升编程水平, 写出更好的代码</title>
      <link href="/2020/03/22/notes/easy-to-change-principle.html"/>
      <url>/2020/03/22/notes/easy-to-change-principle.html</url>
      
        <content type="html"><![CDATA[<p>无论新手还是资深开发者都会经常问一个问题，“怎么写好的代码？”，要知道怎么写好代码，首先我们要知道怎么样才是好的代码。要有明确的目标，才能知道如何达成目标。在《程序员修炼之道》中提到的<code>“ETC Principle” -- 易于改编原则</code>。这个原则看似简单，但是我们越是深入思考越是觉得“简约而不简单”。</p><p>这篇文章里会详细解刨在实际产品研发中“易于改编”的原因和怎么做到“易于改编”， 从而让我们编写出更好的代码。</p><hr><h1 id="「一」程序为何需要“易于改编”？"><a href="#「一」程序为何需要“易于改编”？" class="headerlink" title="「一」程序为何需要“易于改编”？"></a>「一」程序为何需要“易于改编”？</h1><p><img src="https://img-blog.csdnimg.cn/2020032122230564.png" alt="程序为何需要“易于改编”"></p><p>为何代码必须要易于改编？因为一个系统是会随着一个产品的发展，每日有用户增长就会有一直做不完的需求。只要公司一直在运营着这个产品，需求就会随着公司的发展而改变。只要我们开发者一直与时并进专研新技术，我们就需要一直升级优化。</p><p>只有了解清楚一个系统在一个生命周期中，具体什么会推动我们程序改变，从中我们才会更深刻明白为什么我们的代码需要”易于改编“。</p><h2 id="需求会变"><a href="#需求会变" class="headerlink" title="需求会变"></a>需求会变</h2><p>无论我们是研发任何系统，产品需求都是会一直变的。这个是永恒不变的命运。为什么呢？</p><ol><li><strong><code>产品方向</code></strong> — 随着产品的营销，运营，发展会推动产品需求一直新增，修改，优化。</li><li><strong><code>使用量</code></strong> — 随着产品的用户量级，数据量级，并发量级也会推动程序的架构和策略上的变动。</li><li><strong><code>技术升级优化</code></strong> — 甚至是我们使用的语言，框架，依赖包等升级也会引起我们的代码需要适应。</li><li><strong><code>技术债</code></strong> — 可能是因为时间的限制，之前的代码重于实现而质量不佳。</li></ol><p>所以我们的代码会随着岁月的流逝一直在迭代升级优化。</p><h2 id="“可快速更变”是一个软件的核心"><a href="#“可快速更变”是一个软件的核心" class="headerlink" title="“可快速更变”是一个软件的核心"></a>“可快速更变”是一个软件的核心</h2><p>近几年很多技术团队启用了<code>敏捷迭代开发</code>模式。什么是敏捷迭代呢？</p><blockquote><p><strong>敏捷迭代就是把开发周期缩短到 1-4 周。小步快跑的迅速迭代交付功能上线。敏捷迭代的流程分别如下：</strong></p></blockquote><ol><li><strong>确定需求</strong> - 与老板和市场确认需求和流程</li><li><strong>需求评审</strong> - 与开发同频需求里面的功能点和业务流程</li><li><strong>技术反讲</strong> - 开发与产品同频需求，保证双方理解无误区，开发也需要评估开发难度和开发时间</li><li><strong>研发周期</strong> - 开发人员开始投入研发直接到功能和需求开发完毕，转交给测试，在测试环境提测</li><li><strong>测试周期</strong> - 测试和开发人员开始排除缺陷，修复所有在开发过程产生的 bug</li><li><strong>验收/预发布周期</strong> - 当测试在测试环境把所有 bug 排除掉后，当前迭代版本就会发布到预发布环境让市场和产品验收功能</li><li><strong>发布正式</strong> - 当验收通过后，当前迭代版本就可以部署上线到正式环境</li><li><strong>正式回归测试</strong> - 发布上线后，就会有正式回归测试，最后一道防线，保证系统加入的所有新功能都无问题</li><li><strong>迭代总结</strong> - 每一期迭代结束后都总结这次迭代遇到的问题，持续优化，提高效率</li></ol><p>你想想如果一个 APP 或者系统，几个月甚至一年才更新一次功能和升级。我们用起来其实很枯燥的，甚至我们会发现很多问题，还有很多功能可以便捷或者提升我们的使用体验。但是这么久才更新一次，我们还会对这个产品抱有希望吗？（除了微信这种已经很成熟的应用，但是就算是微信也是有持续更新的）。</p><p>所以一个好的产品，是需要快速迭代，小步快跑的迅速迭代交付功能上线的。也是因为这样，功能就需要持续更新、升级和优化。自然我们研发的代码就需要一直随着产品的变化而改编。而且还是每 1-4 周就会升级优化一次。</p><blockquote><p>🏆<strong>小总结一下：</strong></p><ul><li>一个系统会随着产品的发展和迭代，一直走在改变和更新的道路上。</li><li>因为系统一直在变，代码就需要响应系统的变化，持续的快速迭代升级优化。</li><li>既然代码需要快速的更变和升级，那程序的“易于改编”性就必须要高。</li></ul></blockquote><hr><h1 id="「二」如何做到“易于改编”？"><a href="#「二」如何做到“易于改编”？" class="headerlink" title="「二」如何做到“易于改编”？"></a>「二」如何做到“易于改编”？</h1><p><img src="https://img-blog.csdnimg.cn/2020032211021728.png" alt="如何做到“易于改编"></p><p>我们深刻懂得为什么系统会一直在改变，那我们就要知道怎么写代码才能让一个程序“易于改编”，然而在敏捷迭代中才能快速的响应需求的变化。如果想让我们编写的程序更容易的响应需求改变、业务改变和逻辑改变等，我们就要<strong>充分的给我们的程序解刨逻辑</strong>。</p><p>说到逻辑与业务的分解，首先要根据需求和功能深入思考分析，然后对其进行一个架构的设计。最常用的方式就是把系统模块化，组件化等的系统架构设计。</p><h2 id="模块设计-—「Modular-Design」"><a href="#模块设计-—「Modular-Design」" class="headerlink" title="模块设计 —「Modular Design」"></a>模块设计 —「Modular Design」</h2><blockquote><p>模块设计，就是以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。模块化的目的是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。</p></blockquote><p>不论是前端开发还是后端开发，我们都有模块化和组件设计模式。使用模块设计来分解我们的功能和逻辑，目的是为了<strong>降低程序的复杂度、利于调试、维护、修改和新增功能。</strong></p><p>比如现在我们要做个 CMS（内容管理系统），我们一起来尝试使用模块设计来分解这个系统的功能。</p><hr><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>首先我们要理解一个内容管理系统有哪些功能，然后把每个功能划入各个模块里。但是很多童鞋一开始接触一个系统，然后开始瓜分模块会觉得无从入手，可能花了半天坐在电脑前思考 🤔，但是半天都吐不出一个所以然来。接下来让我们一起来学习一套逻辑思维，让我们以后更轻松架构一套模块设计吧！</p><hr><p><strong><code>一开始先思考这个系统的目的和使用场景，这个系统是用来做什么的？</code></strong></p><p>一个内容管理系统，一般来说都是用来发发文章，新闻，或者是一个官方网站的内容管理。那必定就有文章。那管理文章内容，需要什么功能呢？</p><blockquote><p>文章模块 「Article 模块」</p><ul><li>增删查改文章</li><li>文章草稿</li><li>文章置顶</li></ul><hr><p>文章子模块 — 分类 「Article Category 模块」</p><ul><li>增删查改分类</li><li>文章图片</li></ul></blockquote><p>那这些与文章相关的功能是不是可以统一放在<code>“Article”</code>模块中统一管理，然后文章的模块中还有一个文章分类的<code>子模块</code>叫做<code>“Category”</code>。</p><hr><p><strong><code>有文章了必定就需要有作者，那作者在系统中其实是一个用户。那我们就需要有用户模块了。</code></strong> 加上一个管理系统，必定就有管理员，作者，甚至是会员。走一波这个逻辑我们就发现应该要有以下的功能点。</p><blockquote><p>用户模块 「User 模块」</p><ul><li>用户增删查改</li><li>用户身份管理</li><li>用户权限管理</li><li>会员等级管理</li></ul></blockquote><p>这么一来我们就可以建立一个单独的<code>User模块</code>。这个模块主要是管理用户相关的信息和功能。</p><hr><p>看到这里我们应该对一个系统的模块构思有一点的概念了。这个时候产品经理过来给我们提了一个需求，<strong>“我们现在要在这个系统添加一个标签体系，专门用来管理文章标签的。”</strong>。</p><p>那童鞋们，你们觉得这个需求应该放入那个模块呢？🤔<br>….</p><p>你们答对了！🎉 这个是属于文章的一个子模块，<code>Tag模块</code> — 专门管理文章的标签，然后和每一篇文章有多对多关系的。所以<code>标签模块</code>归纳入文章模块中。如果我们的内容管理系统做的很大，里面有视频内容，图文文章等等。我们可以在一开始就把这些统一归纳入“内容模块”，也就是<code>Content</code>模块中。</p><hr><p><strong>前端模块设计</strong></p><p>说到了这里前端的童鞋估计要举手咯 🙋‍♂️，前端的我们求关注呀！“前端是以页面和交互为单位，不可能和后端一样按功能逻辑来分解模块吧？” — 这个童鞋说的在理哈。其实前端和后端的设计上是有稍微的不一样的。</p><p>后端会以业务逻辑来分解模块，但是前端有页面和数据逻辑两块的代码。所以前端相对比后端就要分开两种模块分解思路了。</p><p><strong>页 (排) 面 (版) 的模块设计</strong></p><ul><li>前端的页面模块与产品定义的系统模块会更加贴切一些。前端分解的模块会跟用户所看到的操作功能分组。</li><li>简单的模块分解，可以利用产品童鞋给到我们的导航来分解，这样会更合理的规整我们的页面模块。</li><li>如果在页面功能上再想细分，那就可以用<code>组件设计</code>来分解了。</li></ul><p><strong>前端逻辑模块设计</strong></p><ul><li><p>几年前的前端就是个“切图仔”，基本不用考虑什么业务逻辑，数据逻辑，数据交互这些技术领域。但是因为前后端分离现在已经变成大多数公司的研发策略。慢慢前后端都各自分摊了业务逻辑和数据交互等处理。</p></li><li><p>因为前端也有大量的业务逻辑和交互逻辑，所以在我们封装和解耦的时候，也会遇到需要分解模块来处理。现在最典型的例子就是在使用<code>Vue</code>的状态管理<code>Vuex</code>的时候，需要用到<code>模块管理</code>来分解逻辑，使后面维护和修改更容易。</p></li><li><p>其实前端也是用后端同一套思维模式来分解业务就可以了，以功能为单位来分解你们的模块就可以了。</p></li></ul><hr><h2 id="解耦-「Decoupling」"><a href="#解耦-「Decoupling」" class="headerlink" title="解耦 - 「Decoupling」"></a>解耦 - 「Decoupling」</h2><blockquote><p>解耦，就是把复杂繁琐的逻辑拆分成更小的逻辑块。从而让复杂的逻辑分解成小的逻辑处理，使得逻辑变得更简化，更易于调试和维护。</p></blockquote><p>在一个功能众多、业务复杂和系统模块繁多的系统中，每一个模块里面的代码也会开始变得臃肿，越来越难调试、维护和管理。其实模块化和解耦是一致的。模块化也是为了解耦你的程序。这里我们重点讲的是模块之间和逻辑之间的解耦（Decouping）。</p><blockquote><p>我分享一个经历让大家深刻认知到解耦的重要性。我遇到过最夸张的有一段逻辑处理写了上 5000 行代码的童鞋，然而更可怕的是，在相同功能的地方那 5000 行代码被复制粘贴过来了。😱 我滴乖乖，这位童鞋在研发小组中有个花名叫“复制兄”。不过得到大家的帮忙和提点下，后面他也成为了这个小组中的一名优秀的程序员。</p><hr><p>如果我们不懂得解耦代码，编写的代码会给我们后面带来很重的“技术债”。假设一下，你的 5000 行处理逻辑，在上数十个地方使用了。我们要改一下这段逻辑就难过登天了。就算是这段逻辑没有复用性，但当你需要回头去修改这段逻辑也是会让你头皮发麻，无从入手。修改一点这个逻辑都可能会导致出现 10 个 bug 的后果。</p></blockquote><p>我们深刻知道解耦的重要性，那么我们应该怎么去高效解耦代码呢？</p><p>在《程序员修炼之道》中的 <code>Design by Contract</code> 里提到<strong>我们编写“害羞”的代码是很有益处的。“害羞”有两个含义：“不要把自己暴露给别人”和“不要与过多的人相互影响”。</strong> 这个是什么意思？我们用书中的例子来理解一下。</p><p>在一个庞大的间谍组织中，特工们会分到各个小组，每个小组内部的特工基本都互相认识，但是各个小组之间的特工就都互不相识。假设某个特工被俘虏了，一个小组可能会被摧毁，但是其他小组的特工是不会被暴露被影响的。因为各个小组之间的关系都是绝对隔离的。但是在任务中，各个小组之间都是会有合作和互相帮助，但是都互不相识。所以这么庞大的间谍组织才能长期安全存活下来。</p><p>这个种隔离模式用在编程中是非常好的。把我们的代码解耦到相对独立的模块和方法中，让它们之间的关联性和影响性降到最低。如果一个模块或者逻辑方法出了问题，我们可以独立重构或者修复，而不会给其他模块带来巨大的影响。只要最终的结果是一致的，就可以完美优化升级或者修复了。</p><p>在程序中，我们需要一个<code>Service (服务)</code>给我们处理一个<code>Object（对象）</code>，或者请求一个服务获得一个<code>Object</code>，我们希望这个服务给到我们需要的结果，但是不需要我们去操心它是怎么处理与获得这个<code>Object</code>的。这个服务或者方法是独立运行的，里面的逻辑和代码是与我们写的代码绝对隔离的。我们只需要在获得结果的时候验证这个结果的可用性就可以了，如果结果与我们需要的不一致，那我们就可以抛出错误。只要这个服务做对应的修正，就可以继续运行了。</p><p>理论我们解说的差不多了，现在我们来个实战例子吧：</p><p><strong><code>案例：</code></strong><br>假设现在我们需要写一个获取天气预报数据的类，获取天气预报数据首先你需要提供<code>Geolocation 定位信息</code>参数。<code>Geolocation</code>对象中含有一个地址对象。里面有经纬度，省市区等数据。我们需要获取到地址中的经纬度才能得到精准定点的天气预告信息。我们的代码会这么写：</p><pre><code class="php">/*** 获取天气方法*/public function getWeather(Geolocation $geolocation) {    // 假设我们已经封装了一个获取定位的天气的方法叫getWeatherByGeo()    return $this-&gt;getWeatherByGeo($geolocation-&gt;getLocation()-&gt;getLat());}</code></pre><ul><li>我们通过<code>getLocation</code>方法获取到定位对象里面的地址对象</li><li>然后通过<code>getLat()</code>方法获取到定位地址的经纬度信息</li></ul><p>以上例子中，因为我们需要在<code>geolocation</code>对象中取到经纬度，所以我们需要先经过获取地址对象，然后再通过这个对象获取到经纬度。其实这里面有不需要的关联关系。无论是写服务，还是写对象方法，我们都不要让使用这个服务/对象的开发者去过度的理解和使用你关联性很强的内部方法。这样会导致如果我们那天改变了这个关联性，多处都需要修改代码。</p><p>如果那天<em>刘某</em>改了<code>Geolocation</code>对象，里面不再含有<code>Location</code>对象，而且也没有了<code>getLocation()</code>方法，经纬度可以直接在<code>Geolocation</code>对象中直接取得。这个时候所有之前运用这个对象的其他人都需要修改代码了。很多时候开发者很难修改代码，或者一改动就会伤筋动骨的，其实就是因为这种过多过度的关联性关系导致而为的。</p><p>所以作为<code>Geolocation</code>对象的封装者，我们应该直接给到一个方法<code>getLat()</code>，让调用这个对象的开发者直接能拿到所需要的信息：</p><pre><code class="php">/*** 获取天气方法*/public function getWeather(Geolocation $geolocation) {    // 假设我们已经封装了一个获取定位的天气的方法叫getWeatherByGeo()    return $this-&gt;getWeatherByGeo($geolocation-&gt;getLat());}</code></pre><p>这样就剪断了刚刚对象中的强关联关系的缺陷。</p><hr><h2 id="服务化-—-「Service」"><a href="#服务化-—-「Service」" class="headerlink" title="服务化 — 「Service」"></a>服务化 — 「Service」</h2><p>服务定义：</p><blockquote><p><code>角色</code>：服务是系统架构里面的业务处理层。<br><code>作用</code>：主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。</p></blockquote><h3 id="理解服务"><a href="#理解服务" class="headerlink" title="理解服务"></a>理解服务</h3><ul><li>假设<code>人</code>是一个<code>控制器</code>，现在拿到了一个<code>衣服对象</code>的<code>参数</code>，然后人拥有一个<code>洗衣服</code>的<code>方法</code></li><li>现在人需要洗衣服，但是手洗效率太低了，所以我们写了一个多功能的<code>洗衣机服务</code>给到人去使用</li><li><code>洗衣机</code>这个服务里面有很多不同洗衣服的<code>方法</code>，但是其实具体洗衣机里面的每一个清洗方法人是不知道怎么实现的，人都是直接按照提供的功能直接使用。</li><li>所以服务里面的所有方法都是解耦在服务里面，服务要提供的方法是可以方便人使用的。</li></ul><hr><p>这样说是不是很好理解了？所以最简单的理解就是：</p><blockquote><p>服务是用来封装业务逻辑代码，是一个独立的逻辑层，高度封装解耦后提供给控制器或者其他需要用到这个服务的地方使用的。</p></blockquote><hr><h3 id="编写思路"><a href="#编写思路" class="headerlink" title="编写思路"></a>编写思路</h3><p>❌ <code>错误例子</code></p><blockquote><p>把所有洗衣机的方法提供给人使用，那就等同于让人来决定所有洗衣机的参数和清洗步骤。当人放衣服到洗衣机后，要选择先加水，加多少水，然后清洗开始，清洗多久，再甩干等等。</p></blockquote><p>光想想，洗个衣服还那么多的选项，还要想怎么样的洗衣顺序才是正确的！ 我太难了！洗个鸡腿哦！(ﾉ｀ □ ´)ﾉ ⌒┻━┻</p><p>⭕️ <code>正确例子</code></p><blockquote><p>洗衣机服务实现了很多不同的常用洗衣服的<code>模式</code>, 比如快速清洗，毛衣清洗，地毯清洗，风干，甩干等等。都是一些常用的功能。<br>每个功能方法里面其实调用了很多洗衣机封装好的流程和方法。所以当人使用洗衣机时，根本就不需要知道这些功能是怎么实现的，只要知道自己要干嘛，洗衣机刚好也有这个模式，直接用就完事儿了。</p></blockquote><p>(✧ᗜ✧)👍 哇！ 介么人性化的么！这种洗衣机给我来一打谢谢！</p><p>我写过一篇详细关于编写服务的文章<a href="https://blog.csdn.net/TriDiamond6/article/details/104764227" target="_blank" rel="noopener">《你真的懂怎么写服务层吗？》</a>，有兴趣的童鞋可以前往查看哦。这里我就不详细解说了。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/20200322220709631.jpeg" alt="学懂编程第一法则助你写出更好的代码"></p><p>这篇文章已经到达尾声了，到了这里我们已经深刻知道何为<code>易于改编</code>原则，更懂得如何编写<code>易于改编</code>的代码。其实在开发的过程中，我们还是需要先思考，后设计，再编写。根据所拿到的的功能需求，做好程序的架构设计，从而写出易于改编的程序。只有这样我们编写的代码才能越来越好，走上技术巅峰！</p><hr><p><img src="https://img-blog.csdnimg.cn/20200321131747841.png" alt="和你一起终身学习"></p>]]></content>
      
      
      <categories>
          
          <category> NOTES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programmer </tag>
            
            <tag> Better Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5大法则助你 成为更出色的开发者</title>
      <link href="/2020/03/17/notes/5-principles-to-be-a-better-programmer.html"/>
      <url>/2020/03/17/notes/5-principles-to-be-a-better-programmer.html</url>
      
        <content type="html"><![CDATA[<ol><li>在现在这个技术高速发展的时代，无论你是在校学生，还是技术职场中的精英，都会面临需要持续提升。但是如果只知道提升技术能力，忽略了一些技巧和技术素养的培养和习惯。你会发现你再有能力，也变得无用武之地。因为真正的强者是不会只依赖 TA 的装备。更多的是技巧，经验，应变能力还有思想。</li><li>confg</li></ol><ul><li>在现在这个技术高速发展的时代，无论你是在校学生，还是技术职场中的精英，都会面临需要持续提升。但是如果只知道提升技术能力，忽略了一些技巧和技术素养的培养和习惯。你会发现你再有能力，也变得无用武之地。因为真正的强者是不会只依赖 TA 的装备。更多的是技巧，经验，应变能力还有思想。</li><li>34234324</li></ul><p>在现在这个技术高速发展的时代，无论你是在校学生，还是技术职场中的精英，都会面临需要持续提升。但是如果只知道提升技术能力，忽略了一些技巧和技术素养的培养和习惯。你会发现你再有能力，也变得无用武之地。因为真正的强者是不会只依赖 TA 的装备。更多的是技巧，经验，应变能力还有思想。</p><p>这篇文章会教 5 大法则助我们成为更出色的开发者，在众多开发者中脱颖而出的诀窍，也会在我们的技术职业生涯中给我们很多的帮助。</p><hr><h1 id="一、先思考，后设计，再下手"><a href="#一、先思考，后设计，再下手" class="headerlink" title="一、先思考，后设计，再下手"></a>一、先思考，后设计，再下手</h1><p><img src="https://img-blog.csdnimg.cn/20200315000349561.png" alt="先思考，后设计，再下手"></p><p>多数拿到新功能需求，大致有思路就直接下手开始写代码，半天下来发现这个需求或者功能越想越复杂。前进的路开始迷茫，内心越来越烦躁（甚至开始埋冤产品，这个需求怎么搞那么复杂，太坑了！），秃头的噩梦开始了。(╯ಠ_ ಠ）╯</p><p>其实开始写代码之前，思路就没有整理清楚或者目标不明确，想着想着就偏离了初衷。越深入考虑就越复杂，考虑到解耦代码，封装服务，设计数据库，扩展性，通用型等等这些因素。想想都已经迈入了从 0 到放弃的节奏了。甚至遇到过“杞人忧天”的程序猿小哥哥，小姐姐。TA 们问我说：“如果那一天服务器在我处理的时候停电了怎么办呀，如果服务器爆炸了呢？！”（这种绝对不夸张，还真的有哈）</p><p>其实就是因为前期没有充分的思考和设计所以才会导致后面的手慌脚乱。</p><h2 id="深度思考"><a href="#深度思考" class="headerlink" title="深度思考"></a>深度思考</h2><p>投入代码的海洋之前，我们需要先深度思考这个功能需求，整理清楚它的<code>目的</code>，<code>场景</code>，<code>难点</code>。</p><ol><li><p><strong>明确目的 — <code>明确功能需求的目的，了解清楚它是用来做什么，为了达到什么目的</code>。</strong><br>好比如现在是要开发一个文章搜索。一听到这个，你会想到什么呢？文章标题搜索？全文搜索？拆词搜索？标签化搜索？还能想到更多各式各样的搜索功能可以在这个功能需求中实现。如果不明确目的是什么，可能一开始就想复杂了。最终可能只是需要一个简单的标题搜索而已。而我们花了半天在想一大堆的可能性，系统要承载这个功能需要如何设计。</p></li><li><p><strong>使用场景 — <code>场景因素决定了这个功能的技术架构，也决定它的难度等级</code>。</strong><br>那场景到底是什么？其实就是这个功能规模的影响因素，举个例子：后端来说场景可以是这个文章搜索涉及的数据量级，还有使用的用户量级和并发量级。这些都是会直接关系到后端架构的设计，和代码的编写策略。那如果是前端呢？前端要考虑的因素有：这个搜索是否有重复使用性（是否需要封装成组件），是否需要加强的交互（比如，实时联想历史搜索或者关键词），是否涉及前端需要数据与交互结合处理数据来达到一些特殊交互。这些都是直接和前端的实现方式息息相关的。</p></li><li><p><strong>分析难点 — <code>明确目的，锁定场景后，就可以开始解刨功能需求找到技术难点</code>。</strong><br>注意一个误区，这个思考过程不是决定技术架构和策略，这里只是单纯通过<strong>已有的关联性系统功能，技术能力范围，数据量级，用户量级，开发时效等因素排查出这个功能需求开发的难点</strong>。如果在这里就开始考虑到设计和策略，我们就会过多的花时间在一两个难点上，甚至过度设计。我们的重点是分析出某些部分的存在难度，先解刨出来，后面开始架构设计和策略的时候会特别注意到这些难点。</p></li></ol><blockquote><p><strong>小结一下：</strong> &gt; <strong>在设计和开发一个功能需求前，有一个系统化的思考模式可以让我们快速的明白一个功能需求和整理思路！</strong> 习惯先深度思考，可以大大提高自身技术的成长。慢慢我们会发现你分析一个功能需求会看的更加透彻，开发效率也会随之上升。</p></blockquote><h2 id="设计与策略"><a href="#设计与策略" class="headerlink" title="设计与策略"></a>设计与策略</h2><p>开发任何一个功能，特别是大型系统，我们都是需要有一个架构设计的过程。系统架构设计会包括：</p><ul><li><strong>后端</strong> — 数据库，设计模式，编写策略（例如：<a href="https://blog.csdn.net/TriDiamond6/article/details/104764227" target="_blank" rel="noopener">服务层封装</a>）等。</li><li><strong>前端</strong> — 组件封装，底层工具类，代码接受，模块化等。</li></ul><p>设计这个功能也是有一套方式方法可以提高这方面的效果和能力。</p><ol><li><p><strong>画图</strong> — 使用 UML/思维导图/逻辑图等工具整理自己的功能逻辑流程， 这个可以强化功能的背后的思路。通过画图可以完整的，可视化的整理了一遍你大脑中的功能逻辑思路。大大强化了这个逻辑在你脑海里的影响。在画图的过程中，你还会挖掘出一些细微的问题和缺陷，通过这个过程，你的逻辑思路会得到优化和强化。</p></li><li><p><strong>探讨</strong> — <strong>“集思广益”</strong>，集合大家的力量必定比你一个人想强，所以设计出你的架构和逻辑图后，可以与你的伙伴一起探讨和分享。你会发想 TA 们可以看到你看不多的角度和观点。从而可以更加优化你的设计和逻辑。如果你有看过我写的《<a href="https://blog.csdn.net/TriDiamond6/article/details/104719532" target="_blank" rel="noopener">如果高效学习编程</a>》，应该知道“小黄鸭教学法”，在你讲解你的设计和逻辑思路的过程，从思想转化为语言的过程，你已经在重新整理了一片你的设计思路和逻辑。你可能会在过程中发现一些你预想不到的全新观点。</p></li><li><p><strong>ETC 原则</strong> — <strong>“Easy to change” 易于改编原则</strong>来源于一本书叫《程序员修炼之道》，意思就是代码可以更容易被改遍的才是最好的代码 — “Good code is easy to change”。设计和编程中最重要的一个点就是，保持代码灵活和易于改编重用的架构技术。（这里我先透露一下，近期我也又在准备写一篇专门讲解有关此原则的文章，感兴趣的童鞋，敬请期待，可先关注本博主哦）。在设计架构的时候如果遇到两个或者多个选择，那就遵循 ETC 原则，选择扩展性高，易于改编更好的方案。</p></li></ol><blockquote><p><strong>小结一下：</strong><br>做好功能需求整理和设计模式的建立，对于功能需求的了解已经可以达到一定的深度和理解的相对透彻。这个时候就可以开始一头扎进去代码的海洋了。你会发现自己的代码会写的很顺畅，一种乘风破浪的感觉，恍惚敲代码都带风。</p></blockquote><hr><h1 id="二、把功能需求分解成小任务"><a href="#二、把功能需求分解成小任务" class="headerlink" title="二、把功能需求分解成小任务"></a>二、把功能需求分解成小任务</h1><p><img src="https://img-blog.csdnimg.cn/20200316215013461.png" alt="把功能需求分解成小任务"></p><p>接到一个功能需求时，众多开发者都会觉得，这个需求含有多个功能点，感觉无从入手。还会有一种莫名的复杂感。这个是因为一个功能需求里面很多时候对开发来说都是参合了多个小功能。</p><p>这个时候最好的解决办法就是尽量的<strong>分解需求为多个小任务</strong>。在《<a href="https://blog.csdn.net/TriDiamond6/article/details/104719532" target="_blank" rel="noopener">如果高效学习编程</a>》中也有提到一个观点 — <strong>“化繁为简，小步快跑”</strong>，把复杂的功能拆分成多个小的点，也能让自己会迅速的开展工作。同时也会更有冲劲，每个任务如果太过复杂，实现时间太过长，会慢慢觉得枯燥无味，效率就会大大下降。</p><h2 id="如何分解需求？"><a href="#如何分解需求？" class="headerlink" title="如何分解需求？"></a>如何分解需求？</h2><p>我团队的很多小伙伴一开始自己拆解功能需求的时候，经常会问我，“不知道需求怎么拆解，感觉拆的太细又不实际，但是如果不拆细，又觉得没有拆的必要“。这里我来给大家一些方法来拆解功能需求：</p><ul><li><strong>按流程</strong> — 每个功能需求都有一定有一个或多个的<code>业务流</code>，<code>逻辑流</code>，<code>数据流</code>。可以使用这个流程分解。 + 业务流 — 可以按照业务的流程拆可，比如注册账号，短信通知，推荐联系人。这个系统的注册到通知到推荐联系人。其实都是注册流程中的，但是我们可以按照流程拆开 3 个独立任务进行开发。 + 逻辑流 — 按照不同的业务逻辑拆分你的任务，使用相同注册账号的例子，可以拆分为：检测用户名重复，添加用户的逻辑，推送短信逻辑，建立短信发送服务等等。 + 数据流 — 也可以理解为按照查询数据的逻辑来分割你的功能需求。比如建立账户体系仓库，建立短信发送记录查询仓库等等。</li><li><strong>按功能模块/体系</strong> — 如果你接到的是一个大的功能需求，这个功能可能就含有多个功能模块在其中。比如我们要做一个财务模块，我们可以首先根据功能模块或者体系拆分：对账体系，提现体系，资金流水，银行账户管理，资金管理等等。</li></ul><blockquote><p><strong>小结一下：</strong><br>当我们接到的功能需求较大的时候，我们一定要把需求“化繁为简，小步快跑”的方式进行分解。这个会大大有利于我们提高效率。毕竟在技术开发中长跑是会精疲力尽的，小步快跑才能让我们高效使用脑力。分解需求还能让我们注意到更细微的功能点，那样我们不会在复杂的功能需求中遗漏一下微小的功能点。</p></blockquote><hr><h1 id="三、结队开发，代码评审"><a href="#三、结队开发，代码评审" class="headerlink" title="三、结队开发，代码评审"></a>三、结队开发，代码评审</h1><p><img src="https://img-blog.csdnimg.cn/20200317001239765.png" alt="结伴开发，代码评审"></p><p>在开发的过程中，开发者们往往会沈醉于自己的完美代码之中。我一开始也是如此，自己写了一个服务，无论是命名，写法，封装，逻辑设计，架构设计等等，我都觉得是完美无暇了，甚至觉得都被自己的代码美到了。但是越是这个时候，我们就越是无法发现美中不足。我们要接受一个现实就是<strong>没有最好，只有更好</strong>。</p><p>首先要明白，自身的问题大部分人大概率都会是看不清自己的。内心的想法是：自己一直都是这么做的，所以不会觉得自己是有可以改善的点，也会总以为自己是对的。所以我们需要人来提点和指出我们的不足和缺点。人生如果有一面好的镜子是可以照出自己的不足，推动自己改变，成长，提升。不然人会深醉在自己的迷惑中无法找到自身的缺点，最终就是走入无法突破的瓶颈。</p><p>在开发中也是，找一个或多个开发小伙伴审查自己的代码。因为每个开发者都拥有不同的经验。一个优秀的团队，每一个成员都有自身特别专研的领域和技术能力。或多或少都是一种互补的状态下组成的团队。所以互相审查代码可以达到互相学习，互相吸收彼此的特长和优点，然而达到最大化的互补，共同写出最好的代码。</p><ol><li><p><strong>结队开发</strong> — 其实结对开发，就是每次开发一个功能，你会分配一个伙伴，或者建立一个小组。待开发的过程中，可以彼此讨论架构和设计方案，实现方案等等，互补也互相学习利于成长，<strong>“两人搭配干活不累”</strong>。结队开发也能有效避免很多功能中的细微细节被忽略，还是那句话“两个脑袋必定比一个脑袋强”！</p></li><li><p><strong>坦诚的审查</strong> — 在开发完一个功能后，找到你的队员<strong>互相阅读并且审查彼此的代码，从而互相提出宝贵的意见。</strong> 但是其实很多时候，因为彼此是同事也是开发小组中的战友，在“审查”对方的优秀“作品”的时候给最真实的反馈意见，往往我们和对方心里会觉得这是一种“批判”，一种“批评”。然而因为这种顾虑和心态，让我们在审查的过程中有一种莫名的压力和负担。所以给出的意见不能一针见血。“真实坦诚的话大多数人都不爱听，赞美的谎言都很中听”，也可以说是“忠言逆耳”。但是往往就是最真实的反馈意见是对彼此最有价值。也是这样才能在技术的道路上，让自己看到与明白自身的不足并且更好的去改进，从而在这条道路上彼此都能越发的走的更快更远。<strong>所以如果都想让自己和队员有快速成长，那就更需要我们对彼此的知识成果予以尊重，予以坦诚相待的态度，给予队员代码中不足之处的反馈，也谦虚诚恳的接受别人的意见。这是代码审查重中之重！</strong></p></li></ol><p>在我的团队中提出使用结队开发，代码审查制的时候，我收到很多反馈：“我们本来就是敏捷迭代开发，时间很紧凑，不够时间去审查”，“每个人的技术能力参差不齐，有些人无法读懂彼此的代码”，“功能里面掺合着业务和功能需求的业务流程，对方没有做我的功能业务，看不懂呀”等等等等。一开始大家勇于提出了很多问题。</p><p><strong>那我们怎么搞？不用慌让我们来分析一下，提出解决方案：</strong></p><ul><li><strong>时间问题</strong> — 敏捷迭代中，都是小步快跑，迭代周期根据项目而定，但是大致都是 1-4 周的范围之内。时间确实是比较紧迫的。但是互相审查代码这个好处实在是很多，所以就算要在敏捷迭代中耗费一点时间也是非常值得的。</li></ul><ul><li><strong><code>方案：</code></strong> 每个人在每天早上就花 1 小时，审查前一天小伙伴们提交审核的代码，然后在<code>Gitlab</code>这种代码管理平台中直接在代码中填写反馈意见。这样时间是可控的，也不会让开发者浪费太多时间在审查中。</li></ul><ul><li><strong>能力参差不弃</strong> — 这个是审查中的问题，也是为什么更需要审查的原因。不触动互相审查，在团队中给彼此意见让团队的总体能力拉平，能力中的参差不弃的问题就永无法解决。</li></ul><ul><li><strong><code>方案：</code></strong> 首先开个群，或者开个会议，互相提出自己的优缺点，还有提出自己今年想提升的方面。找到团队成员各自的强项其实问题就好解决了。把强项和有这方面想提升的人结队开发，这样就可以发挥有强项人的能力，同时帮助了有这块短板的战友。而且，别人的强项也可能是你的短板，很少有开发者是方方面面都很强的。别人身上肯定有你可以学到的东西。所以彼此都有良好的学习文化和心态。</li></ul><ul><li><strong>业务不熟悉</strong> — 其实代码审核不是去测试对方的功能和业务，我们是写代码的开发者，不是测试工程师。代码审查的主要目的是为了，提高研发质量，把控代码规范，提高编写能力，提高技术知识。</li></ul><ul><li><strong><code>方案：</code></strong> 所以我们让开发者互相审查的是，代码质量，实现方式，架构设计，代码规范，编写策略等方面，这种是不需要知道业务的，如果这些有涉及业务的需要才那么实现的，可以询问对方计算难点在哪里：是查询？数据的处理？审查的重点放在技术本事不是业务代码的层面上。</li></ul><blockquote><p><strong>小结一下：</strong></p><ul><li><p>开发者基本上都是抱团工作的，这种环境下都是很适合互补互相学习的环境。如果想彼此有快速的成长，那就需要我们互相去给彼此提出坦诚又宝贵的意见，从中吸取彼此的优点和强项。这样每个人在这个团队中都会得到高速的提升。</p></li><li><p>如果你所在的公司领导没有推行这种模式，可以提议一下，如果因为公司的情况不合适，可以自己组队互相分享代码探讨，这样还是能达到互相学习和提升的！</p></li></ul></blockquote><hr><h1 id="四、在安静的环境中开发"><a href="#四、在安静的环境中开发" class="headerlink" title="四、在安静的环境中开发"></a>四、在安静的环境中开发</h1><p><img src="https://img-blog.csdnimg.cn/20200317000950512.png" alt="在安静的环境中开发"></p><p>开发者在日常工作中，都是要高度集中，脑力全开的状态下工作的。所以<strong>环境造成的干扰对开发者而言是很影响效率的</strong>。一个难题，一段代码的思路，都是需要高度集中，在大脑中 1000QPS 的输出速度来思考问题和逻辑。所以如果在过程中被声音，交谈，或者其它环境的干扰，就会被打断思路，然后陷入一个不停的思路重组的过程，大量的时间都被消耗掉了。</p><p>当年我刚刚当上了研发主管，开发于管理并行。发现自己每天都处于高并发状态，同时几件事情在处理，沟通，回答问题，协调工作，分析需求，与产品经理互怼，功能设计，功能规划，任务分解，然后就是研发。这一堆的事情都是日常必须要做的事情。我发现在研发的过程中，总会有那么一两个人来打断我的思路，当我大脑在全速前进的时候，突然在高速公路上出现了一个“程咬金”。解决了 TA 的疑问之后，重新投入研发，需要花至少 10 分钟重新整理思路和投入状态，大脑回归原来的速度。但是万万没想到，第二个人又来了。当时的我就感叹了一句，“做一个小小开发真的是太幸福了”。</p><p>其实不只是技术管理岗会遇到这种问题，做一个研发组的开发者也会遇到，会有产品经理，测试，其他同事来请教你，给你指 bug 等等的事情需要和你沟通。所以这种干扰是无法在岗位或者职责上避免的。</p><p><strong>那我们怎么才能做一个静静的小开发呀？(ლ `Д ́ )ლ</strong>，我来告诉你一些小秘诀吧：</p><ol><li><p><strong>番茄工作法</strong> — 给自己定好 20-60 分钟的高度集中的工作时间，这个时间内谁都不要过来打扰你，如果这个时间段有人来找你，你问一句“不好意思，我现在有点忙，事情紧急吗？不紧急我过 xx 分钟过来找你“。如果对方的事情是不紧急的，你就可以继续投入开发。到了一个 25 分钟阶段结束的时候，你再起来跟对方沟通。时间是很宝贵的，为了可以让大家高效沟通，也高效率开展研发工作。我们要高效运用时间。</p></li><li><p><strong>带上耳机</strong> — 如果音乐会打扰你思路的话，就开一点轻音乐，或者一些大自然环境的声音。这样可以帮助你高度集中，不让自己听到一些能打扰你的声音。这种也是有效的管理好自己的耳门，让自己高度集中在研发中。我一般不会告诉别人，别人看到你带着耳机，高度集中的样子，莫名的会给到 TA 人心理压力和心理负担，会想这一刻过去找你，会不会打扰到你的。</p></li><li><p><strong>免打扰模式</strong> — 在你高度集中的时候，开启手机的免打扰模式，关闭你电脑里面一些与你现在工作无关的应用和网页。只要不是工作的群都可以开启消息免打扰。在你番茄工作法的休息时间段，再去看一看消息，加加水，走动一下放松一下。（但是记得一定要控制自己的休息时间，休息过长会导致完全脱离工作状态，要重新进入状态耗费的时间就会变长）</p></li></ol><blockquote><p><strong>小结一下：</strong><br>技术研发是一个需要高度集中的脑力活，大脑的 QPS 需要保持在较高的速度和状态才能达到高效。所以要学会自控，更要把控好自己所在的环境与人。时间是宝贵的，只有珍惜时间才会在最短时间内达到最大量度的产出。如果你能做到，你会发现你加班会变少，工作效率会提高。</p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完这边文章我们发现做为一个开发者，不只是需要提升自己的技术能力，技术素养也是重中之重。只有技术能力，在职场中会有很多压力，职场中是不会给我们全世界的时间来开发，也不会给我们一个舒适的环境让我们集中。所以作为一个更出色的程序员，我们身上必须拥有更多的防身技能，才能在我们面对各式各样的情况和问题出现时，我们能处于泰然，游刃有余。往往也是这些能耐才能让我们与众多的开发者有明显的区别。</p><p>希望这 5 大法则可以助你在技术行业里成为更出色的开发者，在众多的开发者中脱颖而出，升级加薪，走上技术和人生的巅峰。</p><blockquote><p><strong>最后感谢大家的阅读和支持，你们的点赞和关注都是给予我继续写作最大的动力。</strong> &gt; <strong>让我们一起终身学习，在代码的海洋中找到快乐与自我。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NOTES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Programmer </tag>
            
            <tag> Better Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你体验Vue2和Vue3开发组件有什么区别</title>
      <link href="/2020/03/08/frontend/difference-between-vue-and-vue3.html"/>
      <url>/2020/03/08/frontend/difference-between-vue-and-vue3.html</url>
      
        <content type="html"><![CDATA[<p>我们一直都有关注和阅读很多关于 Vue3 的新特性和功能即将到来。但是我们没有一个具体的概念在开发中会有如何的改变和不一样的体验。还有一些童鞋已经开始又慌又抓狂了 – “又要开始学新的写法了 (ノ ToT )ノ ~┻┻”。</p><p>所以这里我使用 Vue2 和 Vue3 开发一个简单的表格组件来展示一下 Vue2 和 Vue3 开发组件的区别。看完这片文章后，你将会有一个概念 Vue2 和 Vue3 开发组件时的区别，并且为 Vue3 的开发之路做好准备。ღ(◔ڼ◔ღ)ミ</p><p>废话少说，让我们开始吧～ (๑ •̀ㅂ•́)و✧</p><hr><h1 id="创建一个-template"><a href="#创建一个-template" class="headerlink" title="创建一个 template"></a>创建一个 <code>template</code></h1><p>组件来说，大多代码在 Vue2 和 Vue3 都<strong>非常相似</strong>。Vue3 支持<code>碎片(Fragments)</code>，就是说在组件可以拥有多个根节点。</p><p>这种新特性可以减少很多组件之间的<code>div</code>包裹元素。在开发 vue 的时候，我们会发现每一个组件都会有个<code>div</code>元素包裹着。就会出现很多层多余的<code>div</code>元素。<code>碎片(Fragments)</code>解决了这个问题。对于有完美强迫症的童鞋“真的时太棒了”。我们这里的例子里就不展示了，用简单的单根节点的组件。</p><p><strong>Vue2 表格 template</strong></p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;form-element&quot;&gt;    &lt;h2&gt;{{ title }}&lt;/h2&gt;    &lt;input type=&quot;text&quot; v-model=&quot;username&quot; placeholder=&quot;Username&quot; /&gt;    &lt;input type=&quot;password&quot; v-model=&quot;password&quot; placeholder=&quot;Password&quot; /&gt;    &lt;button @click=&quot;login&quot;&gt;      Submit    &lt;/button&gt;    &lt;p&gt;      Values: {{ username + ' ' + password }}    &lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>在 Vue3 的唯一真正的不同在于数据获取。Vue3 中的<code>反应数据（Reactive Data）</code>是包含在一个<code>反应状态（Reactive State）</code>变量中。— 所以我们需要访问这个反应状态来获取数据值。</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;form-element&quot;&gt;    &lt;h2&gt;{{ state.title }}&lt;/h2&gt;    &lt;input type=&quot;text&quot; v-model=&quot;state.username&quot; placeholder=&quot;Username&quot; /&gt;    &lt;input type=&quot;password&quot; v-model=&quot;state.password&quot; placeholder=&quot;Password&quot; /&gt;    &lt;button @click=&quot;login&quot;&gt;      Submit    &lt;/button&gt;    &lt;p&gt;      Values: {{ state.username + ' ' + state.password }}    &lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><hr><h1 id="建立数据-data"><a href="#建立数据-data" class="headerlink" title="建立数据 data"></a>建立数据 <code>data</code></h1><p><strong>这里就是 Vue2 与 Vue3 最大的区别 — Vue2 使用<code>选项类型API（Options API）</code>对比 Vue3<code>合成型API（Composition API）</code></strong></p><p>旧的选项型 API 在代码里分割了不同的属性（properties）：data，computed 属性，methods，等等。新的合成型 API 能让我们用方法（function）来分割，相比于旧的 API 使用属性来分组，这样代码会更加简便和整洁。</p><blockquote><p>现在我们来对比一下 Vue2 写法和 Vue3 写法在代码里面的区别。</p></blockquote><p><strong>Vue2</strong> - 这里把两个数据放入 data 属性中</p><pre><code class="javascript">export default {  props: {    title: String,  },  data() {    return {      username: &#39;&#39;,      password: &#39;&#39;,    };  },};</code></pre><p>在<strong>Vue3.0</strong>，我们就需要使用一个新的<code>setup()</code>方法，此方法在组件初始化构造的时候触发。</p><p>为了可以让开发者对反应型数据有更多的控制，我们可以直接使用到 Vue3 的<code>反应API（reactivity API）</code>。</p><p>使用以下三步来建立<code>反应性数据</code>:</p><ol><li>从 vue 引入<code>reactive</code></li><li>使用<code>reactive()</code>方法来声名我们的数据为反应性数据</li><li>使用<code>setup()</code>方法来返回我们的反应性数据，从而我们的 template 可以获取这些反应性数据</li></ol><p>上一波代码，让大家更容易理解是怎么实现的。</p><pre><code class="javascript">import { reactive } from &#39;vue&#39;;export default {  props: {    title: String,  },  setup() {    const state = reactive({      username: &#39;&#39;,      password: &#39;&#39;,    });    return { state };  },};</code></pre><p>这里构造的反应性数据就可以被<code>template</code>使用，可以通过<code>state.username</code>和<code>state.password</code>获得数据的值。</p><hr><h1 id="Vue2-对比-Vue3-的-methods-编写"><a href="#Vue2-对比-Vue3-的-methods-编写" class="headerlink" title="Vue2 对比 Vue3 的 methods 编写"></a>Vue2 对比 Vue3 的 <code>methods</code> 编写</h1><p><strong>Vue2</strong> 的选项型 API 是把 methods 分割到独立的属性区域的。我们可以直接在这个属性里面添加方法来处理各种前端逻辑。</p><pre><code class="javascript">export default {  props: {    title: String,  },  data() {    return {      username: &#39;&#39;,      password: &#39;&#39;,    };  },  methods: {    login() {      // 登陆方法    },  },};</code></pre><p><strong>Vue3</strong> 的合成型 API 里面的<code>setup()</code>方法也是可以用来操控 methods 的。创建声名方法其实和声名数据状态是一样的。— 我们需要先声名一个方法然后在<code>setup()</code>方法中<code>返回(return)</code>， 这样我们的组件内就可以调用这个方法了。</p><pre><code class="javascript">export default {  props: {    title: String,  },  setup() {    const state = reactive({      username: &#39;&#39;,      password: &#39;&#39;,    });    const login = () =&gt; {      // 登陆方法    };    return {      login,      state,    };  },};</code></pre><hr><h1 id="生命周期钩子-—-Lifecyle-Hooks"><a href="#生命周期钩子-—-Lifecyle-Hooks" class="headerlink" title="生命周期钩子 — Lifecyle Hooks"></a>生命周期钩子 — <code>Lifecyle Hooks</code></h1><p>在 <strong>Vue2</strong>，我们可以直接在组件属性中调用 Vue 的生命周期的钩子。以下使用一个<code>组件已挂载（mounted）</code>生命周期触发钩子。</p><pre><code class="javascript">export default {  props: {    title: String,  },  data() {    return {      username: &#39;&#39;,      password: &#39;&#39;,    };  },  mounted() {    console.log(&#39;组件已挂载&#39;);  },  methods: {    login() {      // login method    },  },};</code></pre><p>现在 <strong>Vue3</strong> 的合成型 API 里面的<code>setup()</code>方法可以包含了基本所有东西。生命周期的钩子就是其中之一！</p><p>但是在 Vue3 生周期钩子不是全局可调用的了，需要另外从 vue 中引入。和刚刚引入<code>reactive</code>一样，生命周期的挂载钩子叫<code>onMounted</code>。</p><p>引入后我们就可以在<code>setup()</code>方法里面使用<code>onMounted</code>挂载的钩子了。</p><pre><code class="javascript">import { reactive, onMounted } from &#39;vue&#39;;export default {  props: {    title: String,  },  setup() {    // ..    onMounted(() =&gt; {      console.log(&#39;组件已挂载&#39;);    });    // ...  },};</code></pre><hr><h1 id="计算属性-Computed-Properties"><a href="#计算属性-Computed-Properties" class="headerlink" title="计算属性 - Computed Properties"></a>计算属性 - <code>Computed Properties</code></h1><p>我们一起试试添加一个计算属性来转换<code>username</code>成小写字母。</p><p>在 <strong>Vue2</strong> 中实现，我们只需要在组件内的选项属性中添加即可</p><pre><code class="javascript">export default {  // ..  computed: {    lowerCaseUsername() {      return this.username.toLowerCase();    },  },};</code></pre><p><strong>Vue3</strong> 的设计模式给予开发者们按需引入需要使用的依赖包。这样一来就不需要多余的引用导致性能或者打包后太大的问题。Vue2 就是有这个一直存在的问题。</p><p>所以在 Vue3 使用计算属性，我们先需要在组件内引入<code>computed</code>。</p><p>使用方式就和<code>反应性数据（reactive data）</code>一样，在<code>state</code>中加入一个计算属性:</p><pre><code class="javascript">import { reactive, onMounted, computed } from &#39;vue&#39;export default {  props: {    title: String  },  setup () {    const state = reactive({      username: &#39;&#39;,      password: &#39;&#39;,      lowerCaseUsername: computed(() =&gt; state.username.toLowerCase())    })    // ...  }</code></pre><hr><h1 id="接收-Props"><a href="#接收-Props" class="headerlink" title="接收 Props"></a>接收 <code>Props</code></h1><p>接收组件<code>props</code>参数传递这一块为我们带来了 Vue2 和 Vue3 之间最大的区别。<strong>—<code>this</code>在 vue3 中与 vue2 代表着完全不一样的东西。</strong></p><p>在 <strong>Vue2</strong>，<code>this</code>代表的是当前组件，不是某一个特定的属性。所以我们可以直接使用<code>this</code>访问 prop 属性值。就比如下面的例子在挂载完成后打印处当前传入组件的参数<code>title</code>。</p><pre><code class="javascript">mounted () {    console.log(&#39;title: &#39; + this.title)}</code></pre><p>但是在 <strong>Vue3</strong> 中，<code>this</code>无法直接拿到 props 属性，emit events（触发事件）和组件内的其他属性。不过全新的<code>setup()</code>方法可以接收两个参数：</p><ol><li><code>props</code> - 不可变的组件参数</li><li><code>context</code> - Vue3 暴露出来的属性（emit，slots，attrs）</li></ol><p>所以在 Vue3 接收与使用 props 就会变成这样：</p><pre><code class="javascript">setup (props) {    // ...    onMounted(() =&gt; {      console.log(&#39;title: &#39; + props.title)    })    // ...}</code></pre><hr><h1 id="事件-Emitting-Events"><a href="#事件-Emitting-Events" class="headerlink" title="事件 - Emitting Events"></a>事件 - <code>Emitting Events</code></h1><p>在 <strong>Vue2</strong> 中自定义事件是非常直接的，但是在 <strong>Vue3</strong> 的话，我们会有更多的控制的自由度。</p><p>举例，现在我们想在点击提交按钮时触发一个<code>login</code>的事件。</p><p>在 <strong>Vue2</strong> 中我们会调用到<code>this.$emit</code>然后传入事件名和参数对象。</p><pre><code class="javascript">login () {      this.$emit(&#39;login&#39;, {        username: this.username,        password: this.password      }) }</code></pre><p>但是在 <strong>Vue3</strong>中，我们刚刚说过<code>this</code>已经不是和 vue2 代表着这个组件了，所以我们需要不一样的自定义事件的方式。</p><p>那怎么办呀？! ლಠ 益 ಠ)ლ</p><p>不用慌，在<code>setup()</code>中的第二个参数<code>content</code>对象中就有<code>emit</code>，这个是和<code>this.$emit</code>是一样的。那么我们只要在<code>setup()</code>接收第二个参数中使用<strong>分解对象法</strong>取出<code>emit</code>就可以在 setup 方法中随意使用了。</p><p>然后我们在<code>login</code>方法中编写登陆事件：</p><pre><code class="javascript">setup (props, { emit }) {    // ...    const login = () =&gt; {      emit(&#39;login&#39;, {        username: state.username,        password: state.password      })    }    // ...}</code></pre><hr><h1 id="最终的-vue2-对比-vue3-代码"><a href="#最终的-vue2-对比-vue3-代码" class="headerlink" title="最终的 vue2 对比 vue3 代码"></a>最终的 vue2 对比 vue3 代码</h1><p><img src="https://img-blog.csdnimg.cn/20200308214440300.png" alt="最终的vue2对比vue3代码"></p><p>真的是太棒了，能看到这里的童鞋们，你们现在基本都看到 vue2 与 vue3 其实概念与理念都是一样的。只是有一些属性获取方式和声名和定义方式稍微变了。一直在鬼哭狼嚎的小小前端开发猿人们，你们可以松一口气了吧。</p><p>总结一下，我觉得 <strong>Vue3</strong> 给我们前端开发者带来了全新的开发体验，更好的使用弹性，可控度也得到了大大的提升。如果你是一个学过或者接触过 <strong>React</strong> 然后现在想使用 Vue 的话，应该特别兴奋，因为很多使用方式都和 React 非常相近了 🎉！</p><p>全新的<code>合成式API（Composition API）</code>可以提升代码的解耦程度 —— 特别是大型的前端应用，效果会更加明显。还有就是按需引用的有了更细微的可控性，让项目的性能和打包大小有更好的控制。</p><p>最后我把完成的 <strong>Vue2</strong> 和 <strong>Vue3</strong> 的组件代码发出来给大家：</p><p><strong>Vue2</strong></p><pre><code class="javascript">&lt;template&gt;  &lt;div class=&#39;form-element&#39;&gt;    &lt;h2&gt; {{ title }} &lt;/h2&gt;    &lt;input type=&#39;text&#39; v-model=&#39;username&#39; placeholder=&#39;Username&#39; /&gt;    &lt;input type=&#39;password&#39; v-model=&#39;password&#39; placeholder=&#39;Password&#39; /&gt;    &lt;button @click=&#39;login&#39;&gt;      Submit    &lt;/button&gt;    &lt;p&gt;      Values: {{ username + ' ' + password }}    &lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  props: {    title: String  },  data () {    return {      username: &#39;&#39;,      password: &#39;&#39;    }  },  mounted () {    console.log(&#39;title: &#39; + this.title)  },  computed: {    lowerCaseUsername () {      return this.username.toLowerCase()    }  },  methods: {    login () {      this.$emit(&#39;login&#39;, {        username: this.username,        password: this.password      })    }  }}&lt;/script&gt;</code></pre><p><strong>Vue3</strong></p><pre><code class="javascript">&lt;template&gt;  &lt;div class=&#39;form-element&#39;&gt;    &lt;h2&gt; {{ state.title }} &lt;/h2&gt;    &lt;input type=&#39;text&#39; v-model=&#39;state.username&#39; placeholder=&#39;Username&#39; /&gt;    &lt;input type=&#39;password&#39; v-model=&#39;state.password&#39; placeholder=&#39;Password&#39; /&gt;    &lt;button @click=&#39;login&#39;&gt;      Submit    &lt;/button&gt;    &lt;p&gt;      Values: {{ state.username + ' ' + state.password }}    &lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive, onMounted, computed } from &#39;vue&#39;export default {  props: {    title: String  },  setup (props, { emit }) {    const state = reactive({      username: &#39;&#39;,      password: &#39;&#39;,      lowerCaseUsername: computed(() =&gt; state.username.toLowerCase())    })    onMounted(() =&gt; {      console.log(&#39;title: &#39; + props.title)    })    const login = () =&gt; {      emit(&#39;login&#39;, {        username: state.username,        password: state.password      })    }    return {      login,      state    }  }}&lt;/script&gt;</code></pre><p>希望这篇文章能让大家体验到一个比较全面的 Vue2 与 Vue3 的开发区别。如果大家还有什么问题，可以在评论中提问哦！</p><p>开发愉快！～</p><p><img src="https://img-blog.csdnimg.cn/20200321131747841.png" alt="和你一起终身学习"></p>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中更简便的数组处理函数.map()，.reduce()，.filter()</title>
      <link href="/2019/11/02/frontend/simplify-your-javascript-with.html"/>
      <url>/2019/11/02/frontend/simplify-your-javascript-with.html</url>
      
        <content type="html"><![CDATA[<p>如果你刚接触JavaScript可能你还没有听说过<code>.map()</code>，<code>.reduce()</code>，<code>.filter()</code>。或者听说过，看过别人用过但是自己在实际项目中没有用过。在国内很多开发项目都是需要考虑IE8的兼容，为了兼容很多JavaScript好用的方法和技巧都被埋没了。但是我发现近几年开始，很多开发项目已经完全抛弃了IE这个魔鬼了。如果你不需要兼容古老的IE浏览器了，那就要开始熟悉一下这几个方法来处理数组。</p><blockquote><p>注意这遍文章说的的3个方法其实在很多其他语言都可以使用到，因为这几个方法和使用概念在很多其他语言都是存在的。</p></blockquote><hr><h1 id="map"><a href="#map" class="headerlink" title=".map()"></a>.map()</h1><p>让我用一个简单的例子告诉你如何使用这个方法。假如你现在有多对象的数组数据 - 每一个对象代表着一个员工的信息。现在你想要的最终结果就是取出所有员工的唯一ID值。</p><pre><code class="javascript">// 员工数据var employees = [  { id: 20, name: &#39;Captain Piett&#39; },  { id: 24, name: &#39;General Veers&#39; },  { id: 56, name: &#39;Admiral Ozzel&#39; },  { id: 88, name: &#39;Commander Jerjerrod&#39; }];// 你想要的结果[20, 24, 56, 88]</code></pre><p>其实要实现这个结果有很多数组处理方式。传统的处理方法就是先定义一个空数组，然后使用<code>.forEach()</code>，<code>.for(...of)</code>，或者是最简单的<code>.for()</code>来组装ID到你定义的数组里面。</p><p>我们来对比一下传统的处理方式和<code>.map()</code>的区别。</p><p>使用<code>.forEach()</code>：</p><pre><code class="javascript">var employeeIds = [];employees.forEach(function (employee) {  employeeIds.push(officer.id);});</code></pre><p>注意使用传统的方式，我们必须有一个预定义的空数组变量才行。但是如果是<code>.map()</code>就会更简单了。</p><pre><code class="javascript">var employeeIds = employees.map(function (employee) {  return employee.id});</code></pre><p>甚至我们可以用更简洁的方式，使用箭头方法（但是需要ES6支持，Babel，或者TypeScript）。</p><pre><code class="javascript">const employeeIds = employees.map(employee =&gt; employee.id);</code></pre><p>所以<code>.map()</code>到底是怎么运作的呢？这个方法有两个参数，第一是回调方法，第二是可选内容（会在回调方法中做为<code>this</code>）。数组里的<code>每个数值/对象会被循环进入到回调方法</code>里面，然后<code>返回新的数值/对象</code>到结果数组里面。</p><p>注意的是结果数组的长度永远都会和被循环的数组的长度一致。</p><hr><h1 id="reduce"><a href="#reduce" class="headerlink" title=".reduce()"></a>.reduce()</h1><p>与<code>.map()</code>相识，<code>.reduce()</code>也是循环一个回调方法，数组里面的每一个元素对回进入回调方法。区别是回调方法返回的值会被传递到下一个回调方法，如此类推（等同于一个累加器）。</p><p><code>.reduce()</code>里的累加值可以是任何属性的值，包括<code>integer</code>，<code>string</code>，<code>object</code>等等。这个累加值会被实力化或者传递到下一个回调方法。</p><p>来上代码，做个简单的例子！假如你有一个飞机师的数组，数组里面有每个飞机师的工龄。</p><pre><code class="javascript">var pilots = [  {    id: 10,    name: &quot;Poe Dameron&quot;,    years: 14,  },  {    id: 2,    name: &quot;Temmin &#39;Snap&#39; Wexley&quot;,    years: 30,  },  {    id: 41,    name: &quot;Tallissan Lintra&quot;,    years: 16,  },  {    id: 99,    name: &quot;Ello Asty&quot;,    years: 22,  }];</code></pre><p>现在我们需要知道所有飞机师累计的总工龄。使用<code>.reduce()</code>就是比吃饭还简单的事情。</p><pre><code class="javascript">var totalYears = pilots.reduce(function (accumulator, pilot) {  return accumulator + pilot.years;}, 0);</code></pre><p>注意我这里第二个参数我传了0。第二个参数是一个累加值的初始值。当然如果场景需要这个初始值也可以传入一个变量或者你需要的值。循环了数组里的每一个元素后，reduce方法会返回最终累加后的值（在我们这个例子中就是<code>82</code>）。</p><blockquote><p>例子里面的<code>acc</code>和<code>accumulator</code>就是累加值变量</p></blockquote><p>如果是使用ES6箭头写法，我们可以写的更加优雅简洁。一行就可以搞掂的事情！</p><pre><code class="javascript">const totalYears = pilots.reduce((acc, pilot) =&gt; acc + pilot.years, 0);</code></pre><p>现在如果我们需要找到哪一位是最有经验的飞机师。这种情况我们一样可以使用<code>.reduce()</code>。</p><pre><code class="javascript">var mostExpPilot = pilots.reduce(function (oldest, pilot) {  return (oldest.years || 0) &gt; pilot.years ? oldest : pilot;}, {});</code></pre><p>这里我把<code>accumulator</code>变量改为<code>oldest</code>代表飞机师里面的老司机。这时候reduce里面的回调方法对比每一个飞机师，每一次飞机师的值进入这个回调方法，工龄更高的就会覆盖<code>oldest</code>变量。最终循环后得到的<code>oldest</code>就是工龄最高的飞机师。</p><p>通过这几个例子，你可以看到使用<code>.reduce()</code>可以简单又优雅的在一个数组里面获取到单个最终值或者对象。</p><hr><h1 id="filter"><a href="#filter" class="headerlink" title=".filter()"></a>.filter()</h1><p>如果你现在的场景是需要在一个数组里面过滤一部分的数据，这个时候<code>.filter()</code>就是你的最好的朋友了。</p><p>我们用回飞机师的数据，并且加入了所属航空公司的值：</p><pre><code class="javascript">var pilots = [  {    id: 2,    name: &quot;Wedge Antilles&quot;,    faction: &quot;Rebels&quot;,  },  {    id: 8,    name: &quot;Ciena Ree&quot;,    faction: &quot;Empire&quot;,  },  {    id: 40,    name: &quot;Iden Versio&quot;,    faction: &quot;Empire&quot;,  },  {    id: 66,    name: &quot;Thane Kyrell&quot;,    faction: &quot;Rebels&quot;,  }];</code></pre><p>加入现在我们想分别筛选出<code>Rebels</code>和<code>Empire</code>两个航空公司的飞机师，使用<code>.filter()</code>就是轻而易举的事情！</p><pre><code class="javascript">var rebels = pilots.filter(function (pilot) {  return pilot.faction === &quot;Rebels&quot;;});var empire = pilots.filter(function (pilot) {  return pilot.faction === &quot;Empire&quot;;});</code></pre><p>就这么简单，如果使用箭头方法（ES6）就更加优雅了：</p><pre><code class="javascript">const rebels = pilots.filter(pilot =&gt; pilot.faction === &quot;Rebels&quot;);const empire = pilots.filter(pilot =&gt; pilot.faction === &quot;Empire&quot;);</code></pre><p>其实原理很简单，只要你的回调方法返回的是<code>true</code>，这个值或者对象就会在新的数组里面了。如果返回的是<code>false</code>就会被过滤掉了。</p><hr><h1 id="结合使用-map-，-reduce-，-filter"><a href="#结合使用-map-，-reduce-，-filter" class="headerlink" title="结合使用 .map()，.reduce()，.filter()"></a>结合使用 .map()，.reduce()，.filter()</h1><p>既然我们刚刚学到的三个函数都是可以用于数组的，并且<code>.map()</code>和<code>.filter()</code>都是返回数组的。那我们就可以串联起来使用。不说多了上代码试试！</p><p>我们用一个有趣一点的数据试验一下，假如现在我们有一个<code>星球大战</code>里面的<code>人物</code>的数组。每个字段的定义如下：</p><blockquote><ul><li><code>Id</code>: 人物唯一ID</li><li><code>name</code>: 人物名字</li><li><code>pilotingScore</code>: 飞行能力指数</li><li><code>shootingScore</code>: 射击能力指数</li><li><code>isForceUser</code>: 是否拥有隔空操控能力</li></ul></blockquote><p>我们的目标：获取<code>拥有隔空操控能力的飞行员的总飞行能力指数</code>。我们先分开一步一步实现这个目标！</p><ul><li>首先我们需要先获取到拥有隔空操控能力的飞行员。</li></ul><pre><code class="javascript">var jediPersonnel = personnel.filter(function (person) {  return person.isForceUser;});// 结果集: [{...}, {...}, {...}] (Luke, Ezra and Caleb)</code></pre><ul><li>这段代码我们获得了3个飞行员对象，分别都是拥有隔空操控能力的飞行员。使用这个对象我们来获取每个飞行员的飞行能力指数值。</li></ul><pre><code class="javascript">var jediScores = jediPersonnel.map(function (jedi) {  return jedi.pilotingScore + jedi.shootingScore;});// 结果: [154, 110, 156]</code></pre><ul><li>获取到每个飞行员的飞行能力指数值后，我们就可以用累加器（<code>.reduce()</code>）获取总飞行能力指数了。</li></ul><pre><code class="javascript">var totalJediScore = jediScores.reduce(function (acc, score) {  return acc + score;}, 0);// 结果: 420</code></pre><p>这里分开实现方式可以达到我们的目标，但是其实我们可以串联起来，可以写的更加简洁又优雅！我们来玩玩更好玩的吧！</p><pre><code class="javascript">var totalJediScore = personnel  .filter(function (person) {    return person.isForceUser;  })  .map(function (jedi) {    return jedi.pilotingScore + jedi.shootingScore;  })  .reduce(function (acc, score) {    return acc + score;  }, 0);</code></pre><p>这样写是不是很优雅！都被这段代码给美到了！❤️</p><p>如果我们使用箭头写法ES6，就更加优雅了！</p><pre><code class="javascript">const totalJediScore = personnel  .filter(person =&gt; person.isForceUser)  .map(jedi =&gt; jedi.pilotingScore + jedi.shootingScore)  .reduce((acc, score) =&gt; acc + score, 0);</code></pre><p>哇！代码原来可以写的那么优雅的么？！想不到吧？</p><blockquote><p>其实我们只需要使用<code>.reduce()</code>就可以得到我们的目标结果了，以上例子做为教学例子，所以使用了3个我们学到的函数。</p><p>我们来看看只用<code>.reduce()</code>怎么实现的，来我们一起来刷新一下三观吧！</p></blockquote><pre><code class="javascript">const totalJediScore = personnel.reduce((acc, person) =&gt; person.isForceUser ? acc + person.pilotingScore + person.shootingScore : acc, 0);</code></pre><p>不敢想象吧？一行就搞定一个功能不是梦！</p><h1 id="为什么抛弃-forEach"><a href="#为什么抛弃-forEach" class="headerlink" title="为什么抛弃 .forEach()?"></a>为什么抛弃 .forEach()?</h1><p>其实我一开始写前端的时候也是一顿撸，来个数组都是撸个for循环，解决一切数组处理问题。但是近几年我开始步入前后端开发，API接口对接。发现数据处理越来越多，如果还是像以前那样什么都用for循环来处理数据，那其实数据处理的代码就会越来越臃肿越来越复杂凌乱。所以我开始抛弃了<code>.forEach()</code>。开始做一个优雅的程序员！</p><p>为什么使用<code>.map()</code>，<code>.filter()</code>，<code>.reduce()</code>写代码更优雅，更美观呢？我们用一个实战例子来对比一下吧。</p><p>假设现在我们对接一个接口，返回的数组里面有两个字段<code>name：人的名称</code>和<code>title：对应的职位</code>。</p><pre><code class="javascript">var data = [  {    name: &quot;Jan Dodonna&quot;,    title: &quot;General&quot;,  },  {    name: &quot;Gial Ackbar&quot;,    title: &quot;Admiral&quot;,  },]</code></pre><p>产品经理给到你的需求是只需要展示这些人的职位称呼。</p><blockquote><p>当然这个时候有一些前端就会说“我只是个小小的前端，后端给我处理吧”。但是，这个接口其实是一个通用的接口，就是获取这些员工的资料的，是在多个地方使用的。如果每一个页面因为需要展示的不一样而要写多一个接口给你，你觉得这样好吗？做为一个优秀的前端工程师🦁️，这种小case你自己就可以很优雅的处理好了。而且，在一个优秀的团队，后端确实是要考虑接口通用性的，这种为了你的方便而给他们带来更臃肿的接口是不可接受的。所以前端这个时候就是要重组数据了。</p></blockquote><p>假设现在产品给你的需求是员工列表展示，要支持只展示员工职称和员工左右信息的两种显示项。这个时候我们就要编写一个数据组装方法来跟进展示要求来改变数据格式。</p><p>因为这个“神马“的需求，我们使用<code>.forEach()</code>来重组数据就相对比较麻烦了，而且代码也会变得臃肿。</p><p>我们忽略了组装数据的方法，直接就当作我们已经写好了一个组装数据的方法为<code>formatElement</code>。如果我们用<code>forEach</code>首先我们就需要定义一个空数组来接收结果。</p><pre><code class="javascript">var results = [];data.forEach(function (element) {  var formatted = formatElement(element);  results.push(formatted);});</code></pre><p>所以我们需要两个方法才能实现这个数据结果，但是为什么要写的那么臃肿呢？因为<code>forEach</code>并没有返回值，单单就给你跑个循环，还需要自己<code>push</code>值到预定义的变量里面。其实一个方法就可以完成了，而且重点是一行代码就完事了。</p><p>来使用我们新学的技巧，用<code>.map()</code>来实现就非常简单优雅了。</p><pre><code class="javascript">var results = data.map(formatElement);</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>你学会了吗？学会了就去尝试用<code>.map()</code>，<code>.reduce()</code>，<code>.filter()</code>来替换你传统的<code>for</code>循环吧！我保证你的代码会越来越简洁，可读性更高。</p><p>如果你喜欢我的这遍文章，记得继续关注我的博客，下一遍文章我们开学习怎么在JavaScript中使用<code>.some()</code>和<code>.find()</code>。</p><p>坚持做一个优雅的程序员，坚持每天敲代码！</p>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效学习编程</title>
      <link href="/2019/11/01/notes/learn-programming-more-effectively.html"/>
      <url>/2019/11/01/notes/learn-programming-more-effectively.html</url>
      
        <content type="html"><![CDATA[<p>编程确实不是一件容易的事情，除了要有较强的<code>逻辑思维</code>，还需要<code>花大量的时间和集中力来提升和维持一定的高度</code>。</p><p>与其他的领域不一样的是，技术每日都在变，所以对于编程初学者是很难一直与时并进的。就算是技术大神和老司机们也是追赶的比较吃力的。在技术领域打滚的这些年里，通过经历和经验总结出一些高效的学习方式和方法，在这篇文章里与大家分享。让我们现在就在技术领域的学习之路上奔跑吧！</p><h1 id="锁定目标，风雨兼程"><a href="#锁定目标，风雨兼程" class="headerlink" title="锁定目标，风雨兼程"></a>锁定目标，风雨兼程</h1><p>在刚刚接触技术的时候，很多人都会比较迷茫。技术领域有前端后端并且各自有多种编程语言。选定前端后端后又发现越过一山还有一山高，面临更多的选择。甚至在技术领域打滚了多年后的技术人员也会迷茫，会开始质疑自己的前景，是否要换一门语言或者多学几门语言。所以锁定目标是高效学习的第一门课。</p><h2 id="选择目标"><a href="#选择目标" class="headerlink" title="选择目标"></a>选择目标</h2><p>如果你的目标是前端开发，前期的学习道路是比较明确的，HTML5+CSS3起步。但是如果你的目标是后端开发，还没有开始就已经有多扇门在你前面，让你瞬间选择困难了。所以这里我们就用后端语言选择作为一个例子讲解学习目标选择方法。</p><blockquote><p>陷入学习目标选择困难症是因为技术每日每夜都在变，方向和未来都在摇摆。但是我们首先要有一个对技术有很好的判定能力。</p></blockquote><p>大家应该很多时候都听过”JAVA才是世界上做好的语言”，”PHP才是世界上最好的语言”等等，这些在自己领域崇拜着自己所爱的语言技术爱好者。TA们并没有错，因为每个开发语言都在特定领域或者项目条件里是最好的语言。不过并<code>没有世界上最好的语言，只有在某一个场景和条件下最适合使用的语言</code>。每一种开发语言都有他擅长最合适的使用场景。</p><ul><li><code>PHP</code> - 更适合小型到中型网页端应用（大型应用就需要其他语言配合使用）</li><li><code>JAVA</code> - 更适合大型应用，企业级应用（中小型应用用JAVA就是大材小用，浪费资源）</li><li><code>PYTHON</code> - 更适合用于爬虫，人工智能，脚本类应用</li></ul><hr><blockquote><p>📖 <strong>目标寻找法：</strong></p><p>所以在选择学习目标的时候，我们要有对技术的判定能力，不要轻易听取一些偏面的评价和定论而下决定。</p><ul><li>选择学习目标时重要的决定因素:<ul><li>在目前最实用的 <em>- 学能用到的更容易上手，也更有价值</em></li><li>难度跨度不要太高 <em>- 难度跨越太大时间成本会越高</em></li><li>感兴趣的 <em>- 感兴趣才更能坚持，更有动力</em></li><li>社区更大的 <em>- 社区越大遇到问题时找答案的途径越多</em></li><li>开源项目优先 <em>- 开源的项目的技术更有未来</em></li></ul></li></ul></blockquote><p>🎯 一旦锁定一个目标就要<code>能懂，能用，能变</code>，再扩张你的学习领域到其他的技术。</p><ul><li><code>能懂</code> - 能懂的技术或者知识的理论和原理；</li><li><code>能用</code> - 能把技术或者知识投入使用，投入实战项目；</li><li><code>能变</code> - 能举一反三学到的技术或者知识，能变通，延伸拓展。</li></ul><hr><h2 id="不要蜻蜓点水"><a href="#不要蜻蜓点水" class="headerlink" title="不要蜻蜓点水"></a>不要蜻蜓点水</h2><p>这一点是很多初学者都会犯的错误。</p><blockquote><p>不要<code>浅入浅出，得不偿失</code>，得不到技能还失去了时间。</p></blockquote><p>学习要一步一个脚印，很多一开始学习编程往往会同时学习多个技术，其实这种学习方式不但没有效果反而还浪费时间浪费生命。锁定一个学习目标就要专注一个点上学习，重点学习。</p><p>举个例子，如果你想成为一个Java开发工程师，你是不需要从C学起，然后C++，最后才开始学习Java。我看到很多开发者刚开始都是这样学习，其实根本不需要从底层技术开始学习。既然你的学习目标是Java，那就直奔重点不浪费时间。稳固了基础开发语言后，选择一个框架开始深入专业实战知识。当你稳固了更专业的实战知识后，就可以开始学习这个技术的周边工具（比如IDE）让开发更加高效便捷。</p><blockquote><p>📖 <strong>专研秘诀：</strong></p><ul><li>学习每一个知识或者技术，一定要深入浅出，<code>深入学习和挖掘，吸取重要知识和技术</code>。</li><li><code>专心</code>，<code>专注</code>，<code>专研</code>是一个技术人才的基本素养！</li></ul></blockquote><hr><h2 id="先专注于会用而不是能用"><a href="#先专注于会用而不是能用" class="headerlink" title="先专注于会用而不是能用"></a>先专注于会用而不是能用</h2><p>很多开发者习惯性会过于专注于工具使用，写法，性能，可扩展性等等。初学者一般都会掉入工具使用和写法的坑，而资深的开发者会过于专注于性能和可扩展性。这时候往往会过度消耗学习时间，甚至忘记最初的学习目标。</p><p>用一个简单易懂的例子，”一个机械工程师不会浪费时间想怎么更好的使用TA的扳手，而是怎么可以组装好一个机器的部件” - 很多人会想，学会用更好的工具不是可以更快地安装好吗？但是现实是，你都还没有弄懂怎么安装，再好再有效的工具对你来说都是无用武之地。所以<code>还没有学会前行，就不要先想着怎么跑</code>。</p><p>再举例，如果你是正在学习使用Vue框架，不要太过于执着怎么使用Vue的周边工具，高级写法，性能隐患问题等等。你的目标应该是创建你的第一个首页然后直接投入开发一个小项目小应用。这样你的产出才是最高的，因为这样做更加专注于学会怎么使用Vue来实现功能，而不是更好的使用Vue框架。</p><blockquote><p>在学习的时候要专注于<code>会使用新的技术</code>，而不是怎么用各种花式技巧来<code>提高使用能力</code>。</p></blockquote><p>还有很多童鞋开始学一门技术时，会先开始看一大堆的知识和书籍，或者去看一些大型的项目用这个技术是怎么实现的。其实更<code>有效的学习方式是小步快跑</code>，学习的过程中开发一个小项目会让你更加有动力也更有趣。</p><p>约定自己在限定时间内完成小目标，如能完成就给自己一点小奖励。例如，你对你自己说“如果我下周五完成这个功能，我就让自己去看个电影”。记住奖励不需要很大，<code>小步快跑，小奖小利</code>，这样才能维持发自内心的动力和驱动力。不过就算没有达成小目标也不用气馁，失败时成功之母，所有成功的人都是通过在失败中总结成长壮大。</p><hr><h1 id="采用学习策略"><a href="#采用学习策略" class="headerlink" title="采用学习策略"></a>采用学习策略</h1><p>每一个人都会有一种最合适自己的学习方式方法，适合我的不一定对你就有效 - 所以找到一种对你有效的学习方法很重要。</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>学习方式方法是通过你日复一日，年复一年不停地尝试和总结得来的一种技巧。我也尝试过很多种方式来学习技术，自从我开始进入技术行业到现在，我换了无数种学习方式才找到最适合自己的一种技巧。</p><p>在一开始刚刚入门的时候，我尝试看很多“从入门到精通”，“XXX语言101”等等，最终的结果都是“从入门到放弃”。后面开始走视频学习之路，发现视频里面的老师说话好像是机器人一样，本来有点失眠症的，没想到一看视频秒睡着，被治好了！我以为我的技术生涯就要结束在这里了～ <code>¯\_(⊙︿⊙)_/¯</code></p><h2 id="建立策略"><a href="#建立策略" class="headerlink" title="建立策略"></a>建立策略</h2><p>前方无绝路 · 希望在转角 ～ 我迅速改变了策略，学习技术和其他领域不一样除了看书，撸视频还需要动手去敲代码。<code>学习任何一门技术，可以遵循以下学习策略，可以让学习的技术和知识更加稳固。</code></p><blockquote><p>📖 <strong>学习策略：</strong></p><p>还是遵循我们之前说到的规则，<code>能懂，能用，能变</code>。</p><ol><li><code>深入了解技术的原理</code> - 了解清楚才能更好的在不同场景下运用自如（可以通过看书，看文档）</li><li><code>通过代码理解运用方式</code> - 看懂基本原理，就可以看看别人是怎么在项目中使用的（在github找开源项目，看教学视屏等等）</li><li><code>实战，做一个小项目</code> - 能懂，能会了就要能用，用新学的技术实现一个功能，做一个小项目，把知识投入实战。</li><li><code>发挥你的想象力</code> - 能用后如果想进阶更高层次，就要发挥你的想象力，能举一反三，在你的小项目里面加功能。</li></ol></blockquote><p>其实上面的策略无非就是学习的过程中必须有的<code>理论</code>，<code>运用</code>和<code>变通</code>。这三个学习维度要保持一个良好的平衡。这个平衡是非常重要的，只有理论那就是“纸上谈兵”，只有理论和运用那只是个“代码搬运工”，如果三个维度你都才是就是“大师”。</p><p>当然所说的平衡不是说1:1:1，完全平衡是很难的。对于一个初学者的话可以先3:2:1，中级就可以开始维持2:3:1，到了高级就可以维持2:2:2了。</p><hr><h1 id="时间管理，提高效率"><a href="#时间管理，提高效率" class="headerlink" title="时间管理，提高效率"></a>时间管理，提高效率</h1><p><code>番茄工作法</code>估计很多人都听说过，但是真正用上可能就很少了，能坚持使用的就更少了。</p><p>很多时候在学习中，或者工作中，我们都是被时间追着跑，这里看一下哪里看一下，不经意就已经过了几个小时，一天就过去了。其实真正有效的产出不大，那是因为你没有合理的管理时间。用番茄工作法就是可以让我们可以追着时间跑，让自己时刻有着时间感，急迫感。自然时间运用上就更加有效了。我现在工作中和学习中都已经在使用番茄工作法，有效管理时间效率。突然发现使用了之后，每个小时我的工作效率提高了很多。</p><blockquote><p>使用方式其实很简单，把学习或者工作时间拆分为<code>25分钟一个小阶段，每25分钟休息5分钟，每4次小阶段休息15到20分钟</code>。</p></blockquote><p>使用这个时间管理法后，你会觉得在25分钟的小阶段里面，你的时间很紧迫的，每一分钟你都觉得很宝贵。你会发现你没有时间去浪费，自然而然的在25分钟内提高了效率。无形中你的学习和工作的集中力就会提升。除了提高了你的效率以外，你会发现一天几个小时的学习或者工作都不觉得很疲惫。因为在25分钟的高度集中后，你合理的调整了休息，让自己非常平衡的控制好疲惫度。所以你会发现一天里面的学习和工作都变得轻松了。</p><blockquote><p>使用番茄工作法提高了学习效率和疲惫度，自然你的学习成果就会更高。如果你觉得我说的这个方法太虚幻了，不妨试一下体验一下，实战说明一切！</p></blockquote><hr><h1 id="多思考，多教学"><a href="#多思考，多教学" class="headerlink" title="多思考，多教学"></a>多思考，多教学</h1><p>通常我们学习都用的是吸🌟大法 <code>🌟ԅ( ͒ ۝ ͒ )</code>，然后实战运用，其实还有很多细节和理论我们并没有理解透测。所以运用就不够自由，无法延伸一些创新的用法，或者举一反三。</p><p>在我事业发展的过程中，从一个小开发，做到一个小组长，到现在技术总监。在我开始带领一个小组，到带领整个技术团队；很多问题和新知识都要通过讲解或者教学来带培养你的组员和队员。这个过程中会遇到各种不同思维程度和学习能力的人，每一个人的理解能力或者理解方式都不一样，甚至看待每一件事情或者知识的角度都不一。你会发现你教学或者讲解某一个知识的时候需要使用各种不同的方式和方法。往往就是这样触发了你自己去换角度思考和理解这个知识，而启发了你自己对这个知识新的认知。</p><blockquote><p>通过教学和讲解来把你的知识传承给另外一个人，需要重新整理思路，逻辑，切换N中方式和说法。这个过程中你会挖掘出新的知识，新的观点，新的思维方式，新的理解角度和深度。这就是自我思维切换而达到的知识深度挖掘和提升的过程。这种就是我们经常说的<code>小黄鸭教学法</code>。</p></blockquote><p>不知道大家有没有听说过，当你思路不清晰，或者有问题无法解决的时候。你可以找一只<code>小黄鸭</code>，你就开始讲解你的思路，逻辑或者问题。这个过程中你开始重新整理自己的思路。如果你把一只啥都不懂的小黄鸭也能让它听懂。那这个时候你的思路，逻辑，理解都更加清晰了，问题起码都解决了50%以上了。我给这个方法取了个名字叫<code>小黄鸭教学法</code>！初级学习的时候要用<code>吸星大法</code>，进阶到高级的时候就要用<code>小黄鸭教学法</code>。能教会一只小黄鸭技术，你就是大神了！</p><hr><h1 id="记录，总结"><a href="#记录，总结" class="headerlink" title="记录，总结"></a>记录，总结</h1><p>除非你是过目不忘，要不看完一本书能记下所有是不可能的。就算记住了但是不可能完全明白透彻。一个程序员经常面对着反复又反复的任务，记录学习进度和总结学习知识很重要。往往你学到一个知识的时候，你会使用这个知识投入实战中。你沉迷在代码海洋之中无法自拔之后，你会发现你已经不记得你入海前学到哪里了。所以记录学习进度很重要。</p><blockquote><p><strong>记录学习方式：</strong></p><ul><li>把学习后的只是写成文档</li><li>把知识写成博客</li><li>总结重点，记录重点</li><li>编写学习规划，就是所谓的<code>todo</code>规划表</li></ul></blockquote><p>在学习中，如果要把知识记录，当你要使用它的时候能快速找到。那你就要有总结知识的习惯。把你学过的知识，技术，技巧都写成文档，写成总结。这样加强你的印象，同时也整理出了属于你自己的开发手册。当你遇到了某些问题的时候就可以通过你自己的开发手册找到答案。</p><hr><h1 id="改掉以下习惯"><a href="#改掉以下习惯" class="headerlink" title="改掉以下习惯"></a>改掉以下习惯</h1><ul><li><strong>完美主义：</strong> 初学者经常会陷入的一个坑，从一开始就追求完美，完美的写法，完美的实现方式，完美的设计模式。其实有时候这些都不是最重要的，反而导致有延迟和延后的严重情况，导致进度一直无法推进。最求完美往往把简单事情变得复杂。不要总是为了完美而无限徘徊，为了最好的解决办法而纠结，为了对的方式而浪费时间。往往在开发中，<code>时间是有限的，需求是无限的，连完成都无法保证，就更没有时间追求完美</code></li><li><strong>对比心态：</strong>很多行业内的新人或者准备入行的，都会去和行业内顶尖的人做对比。有一句很火的话“没有对比就没有伤害”，很多人用来对比好与坏，美与丑。其实另外层意思就是如果对比会对你自身造成打击又何必常常带着对比之心来对待自己和事情呢？对比不一定会有伤害，但是对比的心态才是真正造成伤害的源头。应该先认可自己的优点，接受自己的缺点，然后去找到别人的优点，发现别人的缺点。在别人的优点和缺点给自己带来成长。吸收别人优点，避免自己养成了同等的缺点。<code>优秀的人不是天生比你优秀，而是TA们更懂的不自我透支，更懂得养成在无形之中让自己成长的习惯。</code></li><li><strong>复杂化：</strong>学会把复杂的问题和事情拆分成多个小问题小事情。复杂的问题和事情就会变得更加简单。因为问题和事情往往有多个点需要突破，把每个点拆开逐个突破就会更加简单轻松。<code>从简到繁，如果太复杂，就拆开一个一个更简单的小点，逐个突破。</code></li><li><strong>悲观心态：</strong> 很多人遇到巨大难题时都会来一句“没有办法，做不到”。如果做不到，无论何事，都是自己还没有真正想做！<code>没有做不到的事，只有自己不想做的！失败究其必有原因！成功必有方法！</code></li><li><strong>过度透支：</strong>学习累了就躺穿上休息，吃饱喝足了就坚决不吃了。养好一种自律的习惯，不过度透支自己的时间和生命，这样才能有更好的精神和态度面对问题和困难。近年来有很多给程序员打上的标签，”加班狗”，“无日无夜写代码”，“生活邋遢”，“衣服全是同款黑色”等等。确实，做为一个程序员，我们花了大部分时间都在想问题，编写者神乎奇幻代码和程序。但是我们都往往忘记了自己的身体已经在一点一点透支。到了那一天你停下来了，你会发现，身体不行了，除了写代码其他个方面的能力都没有时间去提升。也没有劲学习成长了，整个人好像很颓废，生无可恋一样。所以<code>学会不透支自己，才有更好的状态和精力学习和突破自己。</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论你是在学习技术还是在学士任何其他领域的知识。在学习这条路上都会有坑坑洼洼，各种颠簸。所以我们学习要有技巧，要有方法才能在有效时间内收获最大化！</p><blockquote><p><strong>学习法门：</strong></p><ol><li>锁定目标 <em>- 选择有用的，对你现在阶段有价值的目标</em></li><li>采用学习策略 <em>- 深入学习，投入实战，总结经验</em></li><li>管理好时间 <em>- 把控好时间，提高效率</em></li><li>多思考，多总结 <em>- 多思考问题，多总结和记录知识</em></li><li>改掉不好的习惯和心态 <em>- 有好的习惯才能更轻松的学习和成长</em></li></ol></blockquote><p>一个人一生是有学不完的知识和技能，然而人一生的时间是有限的。所以要把我们的时间和收益最大化才能比同年龄的人跑的更快，学的更多，能力更强！大家一起在学习的道路上继续加油吧！</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Programming </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真正的`服务层`是怎么写的?</title>
      <link href="/2019/10/19/backend/how-to-write-a-service.html"/>
      <url>/2019/10/19/backend/how-to-write-a-service.html</url>
      
        <content type="html"><![CDATA[<p>其实很多系统架构里面都有服务层，但是服务对很多开发人员来说都有很多不同的定义和写法。甚至在我待过的公司里都有不同的写法和编写模式。每个人每个团队每个项目都有对服务不同的理解。那到底什么是服务，怎么理解才是对的呢？</p><p>你们有没有过无数个夜晚里严重怀疑人生，琢磨着到底哪一种服务才是对的？哪一种才是最好的写法，哪一种才能达到服务的真正意义？因为这种执着，我开始在国外的各种网站，大神们写过的开源大项目里面和文章里面总结出一个大多数研发伙伴们认可的理解方式和编写方式。</p><p>要理解什么是服务，我们先来给<code>服务</code>一个<code>定义</code>，在系统架构里面处于什么<code>角色</code>，<code>作用</code>是什么。</p><hr><h2 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h2><blockquote><p><code>角色</code>：服务是系统架构里面的业务处理层。<br><code>作用</code>：主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。</p></blockquote><p>这个定义没毛病吧？赞同的童鞋在评论里举个手哈 👋。<br>好，有了一个优雅高尚的<code>服务定义</code>，我们来用一个通俗易懂的例子来理解服务。</p><hr><h2 id="理解服务"><a href="#理解服务" class="headerlink" title="理解服务"></a>理解服务</h2><ul><li>假设<code>人</code>是一个<code>控制器</code>，现在拿到了一个<code>衣服对象</code>的<code>参数</code>，然后人拥有一个<code>洗衣服</code>的<code>方法</code></li><li>现在人需要洗衣服，但是手洗效率太低了，所以我们写了一个多功能的<code>洗衣机服务</code>给到人去使用</li><li><code>洗衣机</code>这个服务里面有很多不同洗衣服的<code>方法</code>，但是其实具体洗衣机里面的每一个清洗方法人是不知道怎么实现的，人都是直接按照提供的功能直接使用。</li><li>所以所有服务里面的方法都是解耦在服务里面，服务要提供的方法是可以方便人使用的。</li></ul><hr><p>这样说是不是很好理解了？所以最简单的理解就是：</p><blockquote><p>服务是用来封装业务逻辑代码，是一个独立的逻辑层，高度封装解耦后提供给控制器或者其他需要用到这个服务的地方使用的。</p></blockquote><hr><h2 id="编写思路"><a href="#编写思路" class="headerlink" title="编写思路"></a>编写思路</h2><p>❌ <code>错误例子</code></p><blockquote><p>把所有洗衣机的方法提供给人使用，那就等同于让人来决定所有洗衣机的参数和清洗步骤。那人放衣服到洗衣机后，要选择先加水，加多少水，然后清洗开始，清洗多久，再甩干等等。</p></blockquote><p>就想想这个洗衣机就不想用了，洗个衣服那么多选项，还要想那个设置顺序才是对的！ 我太难了！洗个鸡腿哦！(ﾉ｀□ ´)ﾉ⌒┻━┻</p><p>⭕️ <code>正确例子</code></p><blockquote><p>洗衣机服务实现了很多不同的常用洗衣服的<code>模式</code>, 比如快速清洗，毛衣清洗，地毯清洗，风干，甩干等等。都是一些常用的功能。<br>每个功能方法里面其实调用了很多洗衣机封装好的流程和方法。这样人使用洗衣机根本不需要知道这些功能是怎么实现的，只要知道自己要干嘛，洗衣机有这个模式，直接用就好了。</p></blockquote><p>(✧ᗜ✧)👍哇！ 介么人性化的么！这种洗衣机给我来一打谢谢！<br>思路我们整理清楚了，那么可以开始看看用这种思维模式写成代码是怎么样的。来上机械键盘，开始快乐滴敲代码了！</p><h2 id="服务写法"><a href="#服务写法" class="headerlink" title="服务写法"></a>服务写法</h2><h3 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller 控制器"></a>Controller 控制器</h3><p>首先我们写一个人控制器<code>PersonController.php</code>，作为一个优秀的人类，我们天生就会洗衣服，但是人嘛天生就是懒惰的。所以我们买了一台洗衣机（实现洗衣机<code>服务</code>）并且我们学会了使用洗衣机来洗衣服。（实现<code>wash</code>方法）٩(◦`꒳´◦)۶</p><blockquote><p>一个人<code>PersonController</code>，有一个洗衣服方法<code>wash</code>，需要洗衣服的时候实例洗衣服务<code>new WashingMachineServer()</code>，然后只要把衣服传入洗衣机服务的快洗方法，洗衣机服务就会开始快速<code>quickWash($cloth)</code>清洗了。</p></blockquote><pre><code class="php">// 人控制器class PersonController{    /**    * 洗衣服方法    *     * @param object $cloth 衣服对象    */    public function wash($cloth)    {        $washingMachine = new WashingMachineService();        $washingMachine-&gt;quickWash($cloth); // 调用洗衣机的快速清洗功能    }}</code></pre><p>我们好奇的童鞋们，肯定会好奇，那这个洗衣机（<code>WashingMachineService.php</code>服务) 到底是怎么实现的呢？它的快洗功能是怎么做的呢？那我们就来自己建一部洗衣机，自然就懂了。</p><h3 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h3><p>动手之前我们要先思考，先分析，养成这样的好习惯，代码再也不难写了。</p><blockquote><p>分析的重点分为服务的<code>运作</code>和<code>流程</code>, 可变动的<code>属性</code>，最后就是有那些可以提供的<code>模式</code>。 </p></blockquote><ul><li><strong>洗衣机应该怎么<code>运作</code>和<code>流程</code>的：</strong><ol><li>把衣服放入洗衣机 <code>addCloth()</code></li><li>注入水到洗衣机里 <code>addWater()</code></li><li>开始洗衣服（开始旋转和各种累活）<code>wash()</code></li><li>把水排除洗衣机 <code>flushWater()</code></li><li>把衣服取出 <code>fetchClouth()</code></li></ol></li><li><strong>洗衣机可变动的<code>属性</code>：</strong><ul><li>要把衣服放入洗衣机，我们就需要有个东西来装着，然后才能清洗，所以我们应该有一个洗衣桶 <code>$bucket</code></li><li>根据衣服的量，使用的水量是应该可以调节的。（对我们要节约用水嘛）<code>$washDuration</code></li></ul></li><li><strong>洗衣机最常用的<code>模式</code>：</strong><ul><li>快速洗 <code>quickWash()</code></li></ul></li></ul><hr><blockquote><p><strong>⚠️ 需要注意：</strong>  </p><ul><li>所有洗衣机的内部方法都是 <code>private</code> 私有方法，因为都是给洗衣机使用的，外部的人是不能使用的；</li><li><code>快速清洗</code>和<code>取衣服</code>这两个方法是 <code>public</code> 共有方法，因为是洗衣机提供出去给人使用的方法；</li><li>所有属性都是 <code>protected</code> 保护属性，是洗衣机独有的属性。</li></ul></blockquote><p>现在我们就要使用程序员的魔法，把以上的逻辑和属性转换成代码。<code>(∩◉ω◉)⊃----★</code></p><pre><code class="php">class WashingMachineService{    /**    * 清洗时长 (分钟)    * @var integer    */    protected $washDuration = 60;    /**    * 洗衣机的洗衣桶    * @var array    */    protected $bucket;    /**    * 改变默认洗衣机的清洗时长    * @param integer $duration    */    public function changeWashDuration($duration)    {        $this-&gt;washDuration = intval($duration);        return $this;    }    /**    * 往洗衣机的桶加入水    */    private function addWater()    {        array_merge($this-&gt;bucket, [&#39;water&#39; =&gt; &#39;cold water&#39;]);        return $this;    }    /**    * 把衣服加入洗衣机桶内    */    private function addCloth($cloth)    {        array_merge($this-&gt;bucket, [&#39;cloths&#39; =&gt; $cloth]);        return $this;    }    /**    * 旋转桶把开始洗衣服    */    private function wash()    {        // 使用洗衣机的清洗时长来全换清洗衣服        for ($duration = $this-&gt;washDuration; $duration &gt; 0; $duration--) {            array_rand($this-&gt;bucket, 3);        }        return $this;    }    /**    * 把桶里面的水清除掉    */    private function flushWater()    {        unset($this-&gt;bucket[&#39;water&#39;]);        return $this;    }    /**    * 从洗衣桶里面把衣服拿回出来    */    private function fetchCloths()    {        return $this-&gt;bucket[&#39;cloths&#39;]    }    /**    * 快速清洗衣服方法    */    public function quickWash($cloth)    {        return $this-&gt;changeWashDuration(10) // 重新设置洗衣服的时长                    -&gt;addCloth($cloth) // 加入衣服                    -&gt;addWater() // 加入水                    -&gt;wash() // 开始清洗                    -&gt;flushWater() // 清除水                    -&gt;fetchCloths(); // 最后取出衣服返回    }}</code></pre><p>以上就是一个最基础的服务，有独立的内部方法可以让服务运作起来，也有提供出去的服务模式方法。</p><blockquote><p><strong>⚠️ 需要注意</strong>:<br>服务的重点特性在最后这个 <code>quickWash</code> 快速清洗方法。实现快速清洗是通过使用特定<code>顺序</code>和<code>组合</code>方式调用洗衣机<code>内部方法</code>。这种服务的实现方式，可以把一个服务里面的业务逻辑拆分成多个逻辑块，然后通过不同的顺序和组合来实现某种模式或者功能。这样的服务就非常有弹性，而且所有逻辑块复用性极高。这个也是设计模式里面的<code>模版方法模式（Template Method）</code>。</p></blockquote><p>上面的例子只是写了一个洗衣机10%不到的功能，一个完整的洗衣机还会有很多的逻辑方法。那问题就来了，方法多了这个服务就会开始臃肿。这个时候我们就要想一套解耦封装服务的方式方法。接下来我们来讲解一下怎么更深度的服务封装。</p><hr><h2 id="服务封装"><a href="#服务封装" class="headerlink" title="服务封装"></a>服务封装</h2><p>在日常开发过程中，我们有各种各样的封装和解耦方式。包括<code>内部Trait</code>, <code>内部服务</code>，<code>工厂设计模式</code>。这几种都是可以用来深度封装服务的方式方法。找到了方法，下一步就是要找到怎么封装才是最优解耦思路。解耦的原理就是找到<code>共通点</code>和<code>公用点</code>。然后把这些方法封装起来，解耦出去。</p><h3 id="封装思路"><a href="#封装思路" class="headerlink" title="封装思路"></a>封装思路</h3><blockquote><p>在上面写的洗衣机服务，里面的洗衣桶是很通用的和独立的业务逻辑。所以它是可以解耦封装在一起的。</p><ul><li>洗衣机的<code>bucket</code>洗衣桶属性的方法其实可以封装起来。单独做为一个洗衣桶的服务。</li><li>所有涉及洗衣桶操作的功能和流程都封装到洗衣桶服务里面给洗衣机调用。</li></ul></blockquote><p>使用上面的逻辑，我们可以把<code>洗衣机服务</code>和<code>洗衣桶服务</code>拆分成两块。来吧上机械键盘！</p><hr><h3 id="封装编写"><a href="#封装编写" class="headerlink" title="封装编写"></a>封装编写</h3><ul><li>洗衣机服务 <code>WashingMachineService.php</code></li></ul><pre><code class="php">class WashingMachineService{    /**    * 清洗时长 (分钟)    * @var integer    */    protected $washDuration = 60;    /**    * 改变默认洗衣机的清洗时长    * @param integer $duration    */    public function changeWashDuration($duration)    {        $this-&gt;washDuration = intval($duration);        return $this;    }    /**    * 快速清洗衣服方法    */    public function quickWash($cloth)    {        $washingBucket = new WashingBucketService();        $this-&gt;changeWashDuration(10) // 重新设置洗衣服的时长        // 调用洗衣机的桶去清洗衣服        return $washingBucket-&gt;addCloth($cloth) // 加入衣服                    -&gt;addWater() // 加入水                    -&gt;wash($this-&gt;washDuration) // 开始清洗                    -&gt;flushWater() // 清除水                    -&gt;fetchCloths(); // 最后取出衣服返回    }}</code></pre><ul><li>洗衣桶服务 - <code>WashingBucketService.php</code></li></ul><pre><code class="php">class WashingBucketService{    /**    * 洗衣机的洗衣桶    * @var array    */    protected $bucket;    /**    * 往洗衣机的桶加入水    */    public function addWater()    {        array_merge($this-&gt;bucket, [&#39;water&#39; =&gt; &#39;cold water&#39;]);        return $this;    }    /**    * 把衣服加入洗衣机桶内    */    public function addCloth($cloth)    {        array_merge($this-&gt;bucket, [&#39;cloths&#39; =&gt; $cloth]);        return $this;    }    /**    * 旋转桶把开始洗衣服    */    public function wash($washDuration)    {        // 使用洗衣机的清洗时长来全换清洗衣服        for ($duration = $washDuration; $duration &gt; 0; $duration--) {            array_rand($this-&gt;bucket, 3);        }        return $this;    }    /**    * 把桶里面的水清除掉    */    public function flushWater()    {        unset($this-&gt;bucket[&#39;water&#39;]);        return $this;    }    /**    * 从洗衣桶里面把衣服拿回出来    */    public function fetchCloths()    {        return $this-&gt;bucket[&#39;cloths&#39;]    }}</code></pre><hr><h2 id="提供和调用"><a href="#提供和调用" class="headerlink" title="提供和调用"></a>提供和调用</h2><p>模块与模块或者系统与系统直接都会使用到服务来互相打通业务。这个时候服务就要有一个方式提供出去让外部的模块或者系统调用。</p><blockquote><p><strong>⚠️ 需要注意：</strong><br>这里说的是<code>外部模块</code>或者<code>系统调用</code>，这个是要考虑到如果是微服务的话，每个模块都会在不同的服务器和域名下，这个时候就需要异步调用。这种情况下如果还是用类实例的方式来提供和调用服务后面要改就很麻烦了。</p></blockquote><p>这种情况下目前最优的方式就是服务提供者用<code>Trait</code>给到服务使用者来注入到业务代码里面。</p><ul><li>洗衣机服务Trait - <code>WashingMachineProvider.php</code></li></ul><pre><code class="php">trait WashingMachineProvider{    /**    * 提供洗衣机服务类    */    public washingMachine()    {        return new \WashingMachineService();    }}</code></pre><blockquote><p><strong>⚠️ 需要注意：</strong><br>这里是使用了命名空间来实例洗衣机服务类的。但是如果改成了微服务，那我们只需要改掉所有这些服务提供Trait，把服务类实例改为服务发现，或者异步服务调用就可以了。再也不用花钱去买霸王洗发水了。<code>٩(^ᴗ^)۶</code></p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经历了千辛万苦，无数个失眠的夜晚。终于知道服务到底是什么，应该怎么写，怎么写才是对的。写好服务可以提高代码的维护性，编写的代码也会有更强的逻辑和条理。好的服务也会有更好的弹性和扩张性。下面我们来总结一下编写服务的重点。</p><blockquote><p><code>角色</code>: 服务是系统架构里面的业务处理层。<br><code>作用</code>: 主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。<br><code>思路</code>: 逻辑要独立，分解成逻辑块，保持复用性高，尽量不要限定逻辑使用的顺序和高弹性的组合性。<br><code>编写</code>: 高度封装，高内聚的原理来编写服务，细化分解通用性，公用性的业务，然后封装成一个服务。</p></blockquote><hr><blockquote><p><strong>#通过技术悟出人生道理# 💭</strong><br>  “大千世界每一件事都有千百万种做法，<br>  吸收，打磨，专研，总结，进步，<br>  才会找到最适合的做法。” <small> <em>～ 三·钻 TriDiamond</em><small></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> BackEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Service </tag>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Console技巧提高JS调试技能</title>
      <link href="/2019/10/11/frontend/debugging-skills-console.html"/>
      <url>/2019/10/11/frontend/debugging-skills-console.html</url>
      
        <content type="html"><![CDATA[<p>其实 <strong>JavaScript</strong> 给到我们很多调试工具来调试代码，那问问你自己，你又知道多少呢？用到多少呢？</p><p>大部分前端开发在 <strong>JavaScript</strong> 调试代码的常规用法都是直接<code>console.log</code>，直接输出某一个变量或者返回数据里面的对象数据。当然毋庸置疑这样输出来调试是没有问题的。但是不是最优雅的方式来调试代码，其实还有更好的办法。作为一个有追求的技术人才，有更好的调试方式为什么不去使用呢？</p><p><img src="https://s2.ax1x.com/2019/10/11/ubREy4.png" alt="Console输出Hello"></p><p>我们先来了解清楚浏览器的<code>console</code>。浏览器的<code>console</code>对象有提供自带的调试控制台。<code>console</code>对象只能在浏览器的JavaScript中使用，也就是说客户端应用可用而服务端应用不可用。它的作用或者效果会根据不同的浏览器而不同，但是基础使用方式和功能是基本一致的。不过<code>console</code>是可以在任何前端语言或者框架中使用。</p><hr><h2 id="console-log"><a href="#console-log" class="headerlink" title="console.log"></a>console.log</h2><p>最常用的使用方式就是<code>console.log</code>，对前端开发工程师来说就是家常便饭了。以下是一个简单的使用例子。</p><pre><code class="js">function sayHello(name) {  console.log(name)}sayHello(&#39;Indrek&#39;)</code></pre><blockquote><p>以上<code>sayHello</code>方法接收一个名字，然后在控制台输出出来。</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/12/ujmEr9.png" alt="Console输出名字"></p><p>现在我们开始玩以下更有趣的调试方法。加入我们现在想知道<code>sayHello</code>这个方法被调用了多少次，这样我们应该怎么调试呢？其实有一个很简单的办法就是使用<code>console.count()</code>.</p><hr><h2 id="console-count"><a href="#console-count" class="headerlink" title="console.count"></a>console.count</h2><p><code>count()</code>方法会输出某一个<code>标示</code>被调用了几次。如果没有穿任何参数，<code>count()</code>默认为使用默认标示<code>defaut</code>。</p><pre><code class="js">function sayHello(name) {  console.count()  console.log(name)}sayHello(&quot;Indrek&quot;)sayHello(&quot;William&quot;)sayHello(&quot;Kelly&quot;) </code></pre><blockquote><p>以上代码就会在控制台输出以下结果：</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/12/ujm7ZR.png" alt="统计了sayHello方法被调用的次数"></p><p>上面的例子实现了统计某一个方法被调用的次数，那如果我们想统计每个同名字(<code>name</code>)的在这个方法里面被调用了多少次呢？要调试这种其实也很简单，只要直接吧<code>name</code>直接传入<code>count</code>就可以了。</p><pre><code class="js">function sayHello(name) {  console.count(name)}sayHello(&quot;Indrek&quot;)sayHello(&quot;William&quot;)sayHello(&quot;Kelly&quot;)sayHello(&quot;Indrek&quot;)</code></pre><p><code>‍(∩｀-´)⊃━☆ﾟ.*・｡ﾟ</code> 巴拉巴拉！就是那么简单，我们就可以跟踪同名的参数在<code>sayHello</code>方法里面被调用的次数了！</p><p><img src="https://s2.ax1x.com/2019/10/13/uj1xhR.png" alt="统计同名的参数在`sayHello`方法里面被调用的次数"></p><hr><h2 id="console-warn"><a href="#console-warn" class="headerlink" title="console.warn"></a>console.warn</h2><p>这个控台答应方法会输出一个警告信息。在你开发APIs或者开发工具的时候使用。<code>console.warn</code>这个方法在你需要警告用户的时候特别实用，例如漏掉了某个参数或者是让开发者知道你的API/插件包的版本已经失效的时候使用。</p><pre><code class="js">function sayHello(name) {  if(!name) {    console.warn(&quot;No name given&quot;)  }}sayHello()</code></pre><blockquote><p>上面的代码检测了<code>sayHello</code>方法的参数是否漏传。如果<code>name</code>参数没有传，一个警告消息就会被打印到控制台中。让开发者可以思考问题出在哪里。</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/13/uj85Q0.png" alt="一个警告消息就会被打印到控制台中。让开发者可以思考问题出在哪里"></p><hr><h2 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h2><p>如果是我们在调试数组或者对象时，<code>console.table</code>是一个非常实用的调试方法来在控制台打印数据。数组里面的每一个元素都会在表格的行里面展示。以下是的水果名数组作为一个例子，如果我们把这个数组传入<code>console.table</code>，我们会看到一个含有这个水果名数据以表格的方式在控制台被打印出来。</p><pre><code class="js">const fruits = [&quot;kiwi&quot;, &quot;banana&quot;, &quot;strawberry&quot;]console.table(fruits)</code></pre><blockquote><p>我们一起来围观以下在控制台里面的展示效果</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/13/ujGlkQ.png" alt="数据以表格的形式打印在控制台"></p><p>看到了这个，你会不会灵光一闪想到mmp，如果是一个很大的数组这种表格化的展示方式是多么的实用啊！对的！例如一个上百个数据的数组，我们使用这种调试方法来打印就很方便了。为了可以让我们用双眼见证这个说法的真实性，我们用代码说话吧！</p><pre><code class="js">const fruits = [  &quot;Apple&quot;,  &quot;Watermelon&quot;,  &quot;Orange&quot;,  &quot;Pear&quot;,  &quot;Cherry&quot;,  &quot;Strawberry&quot;,  &quot;Nectarine&quot;,  &quot;Grape&quot;,  &quot;Mango&quot;,  &quot;Blueberry&quot;,  &quot;Pomegranate&quot;,  &quot;Carambola&quot;,  &quot;Plum&quot;,  &quot;Banana&quot;,  &quot;Raspberry&quot;,  &quot;Mandarin&quot;,  &quot;Jackfruit&quot;,  &quot;Papaya&quot;,  &quot;Kiwi&quot;,  &quot;Pineapple&quot;,  &quot;Lime&quot;,  &quot;Lemon&quot;,  &quot;Apricot&quot;,  &quot;Grapefruit&quot;,  &quot;Melon&quot;,  &quot;Coconut&quot;,  &quot;Avocado&quot;,  &quot;Peach&quot;];console.table(fruits);</code></pre><p>我们使用<code>console.table</code>来打印一下上面这个大数组试试看吧。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujGvNQ.png" alt="使用表格化方式在控制台打印数据"></p><blockquote><p>这种展示方式简直就是一目了然！这样妈妈再也不用担心我们调试数据的时候蒙圈了！<code>՞༘✡ (๑ •̀ㅂ•́)و✧</code></p></blockquote><p>但是问题少年们，我们可是有梦想的工程师，如果是用来调试<code>对象</code>会是怎么样呢？来吧亲自动手丰衣足食，上代码！</p><pre><code class="js">const pets = {  name: &quot;Simon&quot;,  type: &quot;cat&quot;};console.table(pets);</code></pre><p>注意了兄弟姐妹们，现在我们打印的是对象不是数组。在控制台的表格现在有两个键值<code>name</code>和<code>type</code>。之前是0，1，2，3，4…</p><p><img src="https://s2.ax1x.com/2019/10/13/ujtOHK.png" alt="控制台表格化打印对象数据"></p><p>这种方式可以替代普遍使用的直接用log打印对象数据，表格化的展示相对还是更加清晰的。问题少年再次发问，如果我们想多个对象一起打印呢？</p><pre><code class="js">const pets = {  name: &quot;Simon&quot;,  type: &quot;cat&quot;};const person = {  firstName: &quot;Indrek&quot;,  lastName: &quot;Lasn&quot;}console.table(pets, person);</code></pre><p>与预想一致，两个不同键值的对象被才分成两个表格在控制台打印出来了。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujNQuq.png" alt="两个对象一起打印"></p><p>如果我们不想分开两个表格打印，可否在一个表格显示呢？可以的！只要把两个对象放入一个数组就ok了。</p><pre><code class="js">const pets = {  name: &quot;Simon&quot;,  type: &quot;cat&quot;};const person = {  firstName: &quot;Indrek&quot;,  lastName: &quot;Lasn&quot;}console.table([pets, person]);</code></pre><p>现在我们看到两个对象在一个表格里面展示了，键值被放在表格的头部了，因为键值在两个对象里面是不一样的。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujNtC4.png" alt="两个对象在一个表格里面打印"></p><hr><h2 id="console-group"><a href="#console-group" class="headerlink" title="console.group"></a>console.group</h2><p>当我们是在调试集合（sets）或者是关联数据（linked-data），可以使用嵌套组来优化你的控制台输出。使用<code>console.group()</code>来创建一个嵌套的组。</p><pre><code class="js">console.log(&quot;This is the first level&quot;);console.group();console.log(&quot;Level 2&quot;);console.group();console.log(&quot;Level 3&quot;);console.warn(&quot;More of level 3&quot;);console.groupEnd();console.log(&quot;Back to level 2&quot;);console.groupEnd();console.log(&quot;Back to the first level&quot;);</code></pre><p>以下是一个嵌套的层级提示输出，在调试关联或者层级数据的时候特别实用。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujNy5D.png" alt=""></p><blockquote><p>使用<code>console.groupCollapsed()</code>可以把所有嵌套的层级收起来，使用鼠标点击时可以展开查看。</p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为一名优秀的程序员，我们应该尽量在合适的场景或者合适的情况下运用在提供到给我的调试工具。所以这一篇文章提到的调试方式，我们应该在开发调试的过程中多合理运用，习惯后我们会发现调试起来会更加敏捷和高效。</p><hr><blockquote><p><strong>#通过技术悟出人生道理# 💭</strong><br>“人生无常，写的了一行是一行<br>Code now or never” <small> <em>～ 三·钻 TriDiamond</em> <small></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
          <category> Tips </category>
          
          <category> Debugging </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Console </tag>
            
            <tag> Debugging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab Webhook 自动部署</title>
      <link href="/2019/09/10/server/aliyun-webhook-setup.html"/>
      <url>/2019/09/10/server/aliyun-webhook-setup.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建与填写部署公钥"><a href="#创建与填写部署公钥" class="headerlink" title="创建与填写部署公钥"></a>创建与填写部署公钥</h2><h3 id="创建部署公钥"><a href="#创建部署公钥" class="headerlink" title="创建部署公钥"></a>创建部署公钥</h3><pre><code class="bash">sudo -Hu www ssh-keygen -t rsa</code></pre><blockquote><p>如果创建失败首先需要创建/home/www/.ssh这个文件夹</p></blockquote><h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><pre><code class="bash">cat /home/www/.ssh/id_rsa.pub</code></pre><h3 id="添加Hook"><a href="#添加Hook" class="headerlink" title="添加Hook"></a>添加Hook</h3><p>在阿里云code.aliyun.com上的profile&gt;ssh_key里面添加公钥</p><h2 id="初始化git项目文件夹"><a href="#初始化git项目文件夹" class="headerlink" title="初始化git项目文件夹"></a>初始化git项目文件夹</h2><pre><code class="bash">sudo -Hu www git clone [git地址]</code></pre><blockquote><p>这里注意, 一定要用www的身份状态要不后期无法自动git pull</p></blockquote><h2 id="自动部署脚本-PHP"><a href="#自动部署脚本-PHP" class="headerlink" title="自动部署脚本 (PHP)"></a>自动部署脚本 (PHP)</h2><h3 id="Shell-exec"><a href="#Shell-exec" class="headerlink" title="Shell_exec"></a>Shell_exec</h3><p>在使用这个PHP脚本的时候我们需要用到<code>shell_exec</code>php的原生函数, php-fpm是默认屏蔽这个函数的, 所有需要在php.ini里面修改一下配置</p><blockquote><p>找到<code>disable_functions</code>这个参数, 并且在里面去掉<code>shell_exec</code></p></blockquote><h3 id="PHP-脚本"><a href="#PHP-脚本" class="headerlink" title="PHP 脚本"></a>PHP 脚本</h3><pre><code class="php">$token = &#39;token&#39;;if (!isset($_GET[&#39;token&#39;]) &amp;&amp; $_GET[&#39;token&#39;] != $token) {    die(&#39;access denied&#39;);}$json = json_decode(file_get_contents(&#39;php://input&#39;), true);$repo = $json[&#39;repository&#39;][&#39;name&#39;];// 只在主分支提交时且提交数大于0执行自动部署if ($json[&#39;ref&#39;]==&#39;refs/heads/master&#39; &amp;&amp; $json[&#39;total_commits_count&#39;]&gt;0) {    $pull_result = shell_exec(&#39;cd /to/project/path/ &amp;&amp; git pull&#39;);    if ($pull_result) {        $res_log = &#39;----------pull 成功---------------&#39;.PHP_EOL;        $res_log .= $json[&#39;user_name&#39;] . &#39; 在&#39; . date(&#39;Y-m-d H:i:s&#39;) . &#39;向&#39; . $json[&#39;repository&#39;][&#39;name&#39;] . &#39;项目的&#39; . $json[&#39;ref&#39;] . &#39;分支push了&#39; . $json[&#39;total_commits_count&#39;] . &#39;个commit：&#39; . PHP_EOL;        $res_log .= $pull_result.PHP_EOL;        file_put_contents(&quot;cityconcierge-webhook-log.txt&quot;, $res_log, FILE_APPEND);//追加写入    } else {        $res_log = &#39;------------pull 失败-------------&#39;.PHP_EOL;        $res_log .= $json[&#39;user_name&#39;] . &#39; 在&#39; . date(&#39;Y-m-d H:i:s&#39;) . &#39;向&#39; . $json[&#39;repository&#39;][&#39;name&#39;] . &#39;项目的&#39; . $json[&#39;ref&#39;] . &#39;分支push了&#39; . $json[&#39;total_commits_count&#39;] . &#39;个commit：&#39; . PHP_EOL;        $res_log .= $pull_result.PHP_EOL;        file_put_contents(&quot;cityconcierge-webhook-log.txt&quot;, $res_log, FILE_APPEND);//追加写入    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitlab </tag>
            
            <tag> Webhook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen 使用 laravel passport</title>
      <link href="/2019/01/10/laravel/lumen-passport-usage.html"/>
      <url>/2019/01/10/laravel/lumen-passport-usage.html</url>
      
        <content type="html"><![CDATA[<p>Lumen是laravel的简洁版, 把laravel里面深重的依赖都去掉了, 所以直接安装laravel的passport是无法正常使用的.<br>所以如果要在lumen上使用laravel的passport就需要安装另外一个插件.</p><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><ul><li>PHP &gt;= 5.6.3</li><li>Lumen &gt;= 5.3</li></ul><h2 id="Composer安装lumen-passport插件"><a href="#Composer安装lumen-passport插件" class="headerlink" title="Composer安装lumen-passport插件"></a>Composer安装lumen-passport插件</h2><p>首先安装 Lumen Passport</p><pre><code class="bash"># 进入项目根目录$ cd lumen-app# 使用composer安装插件$ composer require dusterio/lumen-passport</code></pre><h2 id="修改-bootstrap-bootstrap-app-php"><a href="#修改-bootstrap-bootstrap-app-php" class="headerlink" title="修改 bootstrap (bootstrap/app.php)"></a>修改 bootstrap (bootstrap/app.php)</h2><p>需要引入Laravel Passport的provider和Lumen的一些provider</p><pre><code class="php">// 开启 Facades$app-&gt;withFacades();// 开启 Eloquent$app-&gt;withEloquent();// 开启 auth 中间件$app-&gt;routeMiddleware([    &#39;auth&#39; =&gt; App\Http\Middleware\Authenticate::class,]);// 注册laravel passport的provider和lumen passport的provider$app-&gt;register(Laravel\Passport\PassportServiceProvider::class);$app-&gt;register(Dusterio\LumenPassport\PassportServiceProvider::class);</code></pre><h2 id="数据表移植和安装Laravel-Passport"><a href="#数据表移植和安装Laravel-Passport" class="headerlink" title="数据表移植和安装Laravel Passport"></a>数据表移植和安装Laravel Passport</h2><pre><code class="bash"># 移植passport的数据表php artisan migrate# 安装passport需要的配置php artisan passport:install</code></pre><h2 id="Lumen-Passport自带的路由"><a href="#Lumen-Passport自带的路由" class="headerlink" title="Lumen Passport自带的路由"></a>Lumen Passport自带的路由</h2><p>这个lumen-passport包已经引入了一下路由, 但是与web相关的路由因为lumen是没有web的路由的, 只有api的, 所以这个插件已经把web端的路由都去掉了.</p><table><thead><tr><th>Verb</th><th>Path</th><th>NamedRoute</th><th>Controller</th><th>Action</th><th>Middleware</th></tr></thead><tbody><tr><td>POST</td><td>/oauth/token</td><td></td><td>\Laravel\Passport\Http\Controllers\AccessTokenController</td><td>issueToken</td><td>-</td></tr><tr><td>GET</td><td>/oauth/tokens</td><td></td><td>\Laravel\Passport\Http\Controllers\AuthorizedAccessTokenController</td><td>forUser</td><td>auth</td></tr><tr><td>DELETE</td><td>/oauth/tokens/{token_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\AuthorizedAccessTokenController</td><td>destroy</td><td>auth</td></tr><tr><td>POST</td><td>/oauth/token/refresh</td><td></td><td>\Laravel\Passport\Http\Controllers\TransientTokenController</td><td>refresh</td><td>auth</td></tr><tr><td>GET</td><td>/oauth/clients</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>forUser</td><td>auth</td></tr><tr><td>POST</td><td>/oauth/clients</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>store</td><td>auth</td></tr><tr><td>PUT</td><td>/oauth/clients/{client_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>update</td><td>auth</td></tr><tr><td>DELETE</td><td>/oauth/clients/{client_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>destroy</td><td>auth</td></tr><tr><td>GET</td><td>/oauth/scopes</td><td></td><td>\Laravel\Passport\Http\Controllers\ScopeController</td><td>all</td><td>auth</td></tr><tr><td>GET</td><td>/oauth/personal-access-tokens</td><td></td><td>\Laravel\Passport\Http\Controllers\PersonalAccessTokenController</td><td>forUser</td><td>auth</td></tr><tr><td>POST</td><td>/oauth/personal-access-tokens</td><td></td><td>\Laravel\Passport\Http\Controllers\PersonalAccessTokenController</td><td>store</td><td>auth</td></tr><tr><td>DELETE</td><td>/oauth/personal-access-tokens/{token_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\PersonalAccessTokenController</td><td>destroy</td><td>auth</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改 <code>config/auth.php</code> 里面的配置, 按照项目需要修改. 下面是一个简单的例子</p><pre><code class="php">return [    &#39;defaults&#39; =&gt; [        &#39;guard&#39; =&gt; &#39;api&#39;,        &#39;passwords&#39; =&gt; &#39;users&#39;,    ],    &#39;guards&#39; =&gt; [        &#39;api&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;passport&#39;,            &#39;provider&#39; =&gt; &#39;users&#39;,        ],    ],    &#39;providers&#39; =&gt; [        &#39;users&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39; =&gt; \App\User::class        ]    ]];</code></pre><p>需要在 <code>vendor\laravel\lumen-framework\config\auth.php</code> 复制到项目根目录下的<code>config</code>文件夹里面, 如果没有config文件夹, 需要手动添加一个.</p><p>然后在<code>bootstrap/app.php</code>最前面加入配置应用, 因为lumen是不自动引入config里面的配置的.</p><pre><code class="php">$app-&gt;configure(&#39;auth&#39;);</code></pre><h2 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h2><p>需要在<code>Provider\AuthServiceProviders.php</code>里面的<code>boot</code>方法里面注册路由</p><pre><code class="php">/*** Boot the authentication services for the application.** @return void*/public function boot(){    // Here you may define how you wish users to be authenticated for your Lumen    // application. The callback which receives the incoming request instance    // should return either a User instance or null. You&#39;re free to obtain    // the User instance via an API token or any other method necessary.    LumenPassport::routes($this-&gt;app); // 注册路由    LumenPassport::tokensExpireIn(Carbon::now()-&gt;addDays(7));    LumenPassport::refreshTokensExpireIn(Carbon::now()-&gt;addDays(30));}</code></pre><p>简单路由注册</p><pre><code class="php">Dusterio\LumenPassport\LumenPassport::routes($this-&gt;app);</code></pre><p>通用版本控制的路由</p><pre><code class="php">Dusterio\LumenPassport\LumenPassport::routes($this-&gt;app, [&#39;prefix&#39; =&gt; &#39;v1/oauth&#39;]);</code></pre><h2 id="用户模型"><a href="#用户模型" class="headerlink" title="用户模型"></a>用户模型</h2><p>需要在用户模型里面加入<code>HasApiTokens</code>的trait, 例子:</p><pre><code class="php">class User extends Model implements AuthenticatableContract, AuthorizableContract{    use HasApiTokens, Authenticatable, Authorizable;    /* rest of the model */}</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他的详细文档可以查看lumen-passport的插件<a href="https://github.com/dusterio/lumen-passport" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel Passport </tag>
            
            <tag> Lumen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen passport实现多个用户体系下的oauth验证</title>
      <link href="/2019/01/10/laravel/lumen-multi-oauth.html"/>
      <url>/2019/01/10/laravel/lumen-multi-oauth.html</url>
      
        <content type="html"><![CDATA[<p>这个教程是基于, lumen里面已经安装好了lumen-passport的插件, 如果还没有的话可以先到<a href="/2019/01/10/2019-01-10-lumen-passport-usage/">lumen使用laravel passport教程</a>先安装.</p><h2 id="改写Laravel-Passport里面的UserRepository"><a href="#改写Laravel-Passport里面的UserRepository" class="headerlink" title="改写Laravel Passport里面的UserRepository"></a>改写Laravel Passport里面的<code>UserRepository</code></h2><blockquote><p>文件路径 <code>vendor\laravel\passport\src\Bridge\UserRepository.php</code></p></blockquote><ul><li><p>首先需要改写<code>userRepositroy</code>里面的<code>getUserEntityByUserCredentials</code>方法</p></li><li><p>复制<code>userRepositroy</code>里面的<code>getUserEntityByUserCredentials</code>方法, 改名为<code>getEntityByUserCredentials</code></p></li><li><p>在新建的方法里面找到一下代码</p></li></ul><pre><code class="php">$provider = config(&#39;auth.guards.api.provider&#39;);</code></pre><p>改成一下样子</p><pre><code class="php">$provider = config(&#39;auth.guards.&#39;.$provider.&#39;.provider&#39;);</code></pre><ul><li>然后在新的方法<code>getEntityByUserCredentials</code>的参数里面添加新的参数<code>$provider</code></li></ul><pre><code class="php">public function getEntityByUserCredentials($username, $password, $grantType,   ClientEntityInterface $clientEntity, $provider) {      //...}</code></pre><h2 id="修改oauth2-server里面的PasswordGrand"><a href="#修改oauth2-server里面的PasswordGrand" class="headerlink" title="修改oauth2-server里面的PasswordGrand"></a>修改oauth2-server里面的PasswordGrand</h2><blockquote><p>文件路径 <code>vendor\league\oauth2-server\src\Grant\PasswordGrant.php</code></p></blockquote><ul><li>修改<code>validateUser</code>方法里面的这一串代码:</li></ul><pre><code class="php">$user = $this-&gt;userRepository-&gt;getEntityByUserCredentials(    $username,    $password,    $this-&gt;getIdentifier(),    $client,    $provider // 新加的provider字段);</code></pre><ul><li>在同一个方法里面加入新参数的获取</li></ul><pre><code class="php"> $provider = $this-&gt;getRequestParameter(&#39;provider&#39;, $request); if (is_null($provider)) { throw OAuthServerException::invalidRequest(&#39;provider&#39;); }</code></pre><h2 id="在auth-php配置里面加入新的guard"><a href="#在auth-php配置里面加入新的guard" class="headerlink" title="在auth.php配置里面加入新的guard"></a>在auth.php配置里面加入新的guard</h2><p>首先需要加入新的guard配置</p><pre><code class="php">&#39;guards&#39; =&gt; [    // 原有的api guard    &#39;api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;passport&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],    // 新加的admin-api guard    &#39;admin-api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;passport&#39;,        &#39;provider&#39; =&gt; &#39;admins&#39;,    ],],</code></pre><p>添加新<code>admin-api</code> guard的provider</p><pre><code class="php">&#39;providers&#39; =&gt; [    &#39;users&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;eloquent&#39;,        &#39;model&#39; =&gt; \App\Models\General\MemberLogin::class    ],    // 新加的admins provider对应不用的用户模型    &#39;admins&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;eloquent&#39;,        &#39;model&#39; =&gt; \App\Models\Backend\Manager::class    ]],</code></pre><h2 id="路由middleware使用"><a href="#路由middleware使用" class="headerlink" title="路由middleware使用"></a>路由middleware使用</h2><p>区别在于middleware, 上文加入的新<code>admin-api</code>guard, 在新的路由里面就可以使用<code>auth:admin-api</code>的权限验证中间件理实现权限控制了!</p><pre><code class="php">/*|--------------------------------------------------------------------------| Admin API版本 v1 路由|--------------------------------------------------------------------------.|| prefix admin/api/api版本号| namespace Api\api版本号|*/$app-&gt;group([&#39;prefix&#39; =&gt; &#39;admin/api/v1&#39;, &#39;namespace&#39; =&gt; &#39;AdminApi\V1&#39;], function ($app) {    // ================ 不受登录权限控制的接口路由 ================ //    //测试    $app-&gt;get(&#39;test&#39;, &#39;ExampleController@test&#39;);    // ================ 受登录权限控制的接口路由 ================ //    $app-&gt;group([&#39;middleware&#39; =&gt; &#39;auth:admin-api&#39;], function ($app) {        //测试        $app-&gt;get(&#39;test2&#39;, function(){            return &#39;oauth test&#39;;        });        //测试        $app-&gt;get(&#39;test3&#39;, &#39;ExampleController@test&#39;);    });});</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用了多个guard的时候, 在使用laravel默认的<code>$request-&gt;user()</code>, 这个方法默认是使用<code>api</code>guard的, 可以在<code>auth.php</code>配置里面看到默认guard的配置.</p><pre><code class="php">/*|--------------------------------------------------------------------------| Authentication Defaults|--------------------------------------------------------------------------|| This option controls the default authentication &quot;guard&quot; and password| reset options for your application. You may change these defaults| as required, but they&#39;re a perfect start for most applications.|*/&#39;defaults&#39; =&gt; [    &#39;guard&#39; =&gt; env(&#39;AUTH_GUARD&#39;, &#39;api&#39;),    &#39;passwords&#39; =&gt; &#39;users&#39;,],</code></pre><p>所以在使用新的<code>admin-api</code> guard的时候在使用<code>$request-&gt;user()</code>时需要加入对应的guard. 例子:</p><pre><code class="php">namespace App\Http\Controllers\AdminApi\V1;use App\Http\Controllers\Controller;use Illuminate\Http\Request;use Illuminate\Support\Facades\Cache;class ExampleController extends Controller{    public function test(Request $request)    {        $request-&gt;user(&#39;admin-api&#39;)-&gt;toArray(); // 获取到admin-api下的用户信息    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel Passport </tag>
            
            <tag> Lumen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 实现首页双击退出APP</title>
      <link href="/2017/04/24/ionic/listen-to-back-button.html"/>
      <url>/2017/04/24/ionic/listen-to-back-button.html</url>
      
        <content type="html"><![CDATA[<h2 id="添加绑定值"><a href="#添加绑定值" class="headerlink" title="添加绑定值"></a>添加绑定值</h2><blockquote><p>首先在<code>app/app.html</code>下加入<code>#myNav</code>, 这个是用于绑定当前页面的导航标签</p></blockquote><pre><code class="html"> &lt;ion-nav #myNav [root]=&quot;rootPage&quot;&gt;&lt;/ion-nav&gt;</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>然后在<code>app.component.ts</code>做相对的改动</p></blockquote><pre><code class="ts">import { Component, ViewChild } from &#39;@angular/core&#39;;import { Platform, ToastController, Nav, App } from &#39;ionic-angular&#39;;import { StatusBar } from &#39;@ionic-native/status-bar&#39;;import { SplashScreen } from &#39;@ionic-native/splash-screen&#39;;@Component({  templateUrl: &#39;app.html&#39;,  providers: [SplashScreen, StatusBar]})export class MyApp {  rootPage = &#39;TabsPage&#39;;  backButtonPressed: boolean = false;  //用于判断返回键是否触发  @ViewChild(&#39;myNav&#39;) nav: Nav;  constructor(public platform: Platform, private splashScreen: SplashScreen, private statusBar: StatusBar, public app: App, public toastCtrl: ToastController) {    platform.ready().then(() =&gt; {      // Okay, so the platform is ready and our plugins are available.      // Here you can do any higher level native things you might need.      this.statusBar.styleDefault();      this.statusBar.backgroundColorByHexString(&#39;#661F22&#39;);      this.splashScreen.hide();      this.registerBackButtonAction(); //运行这个方法绑定返回按钮    });  }  registerBackButtonAction() {    this.platform.registerBackButtonAction(() =&gt; {      //如果想点击返回按钮隐藏toast或loading或Overlay就把下面加上      // this.ionicApp._toastPortal.getActive() || this.ionicApp._loadingPortal.getActive() || this.ionicApp._overlayPortal.getActive();      let nav = this.app.getActiveNav();      if (nav.canGoBack()){ //是否已经到了首页        nav.pop();      }else{        this.showExit()      }    }, 1);  }  //双击退出提示框  showExit() {    if (this.backButtonPressed) { //当触发标志为true时，即2秒内双击返回按键则退出APP      this.platform.exitApp();    } else {     this.toastCtrl.create({      message: &#39;再按一次退出应用&#39;,      duration: 2000,      position: &#39;middle&#39;     }).present();     this.backButtonPressed = true;     setTimeout(() =&gt; this.backButtonPressed = false, 2000);//2秒内没有再次点击返回则将触发标志标记为false    }  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ionic 2 </tag>
            
            <tag> Hybird App </tag>
            
            <tag> Angular 4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 3 使用sliders轮播时拖动后autoplay失效解决方法</title>
      <link href="/2017/04/20/ionic/sliders-autoplay.html"/>
      <url>/2017/04/20/ionic/sliders-autoplay.html</url>
      
        <content type="html"><![CDATA[<h4 id="我们先了解一下Ionic的Sliders"><a href="#我们先了解一下Ionic的Sliders" class="headerlink" title="我们先了解一下Ionic的Sliders"></a>我们先了解一下Ionic的Sliders</h4><blockquote><p>首先Ionic里面的sliders是用<a href="http://idangero.us/swiper/api/#.WPhzbPB96Uk" target="_blank" rel="noopener">Swiper.js</a>的第三方插件实现的, Ionic官方Sliders的文档里面只描述了可以直接写入html标签内的属性, 有很多高级属性是没有写在文档里面的. </p></blockquote><h4 id="要怎么改变sliders的其他属性呢"><a href="#要怎么改变sliders的其他属性呢" class="headerlink" title="要怎么改变sliders的其他属性呢?"></a>要怎么改变sliders的其他属性呢?</h4><blockquote><p>那如果我们要用到Swiper的其他属性怎么办呢? Ionic 2.x 的时候我们是可以在options里面传入的, 但是升级Ionic 3.x.x 后sliders的options属性被移除了. 现在要改变sliders的属性我们要用到sliders类. </p></blockquote><h4 id="如何拖动轮播图后不让autoplay失效呢"><a href="#如何拖动轮播图后不让autoplay失效呢" class="headerlink" title="如何拖动轮播图后不让autoplay失效呢?"></a>如何拖动轮播图后不让autoplay失效呢?</h4><blockquote><p>首先我们要引入<code>viewChild</code>和<code>Sliders</code></p></blockquote><pre><code class="ts">import { ViewChild } from &#39;@angular/core&#39;;import { Slides } from &#39;ionic-angular&#39;;</code></pre><blockquote><p>然后使用<code>ionViewWillEnter</code>在进入页面前改变sliders的<code>autoplayDisableOnInteraction</code>属性</p></blockquote><pre><code class="ts">import { ViewChild } from &#39;@angular/core&#39;;import { Slides } from &#39;ionic-angular&#39;;class MyPage {  @ViewChild(Slides) slides: Slides;  ionViewWillEnter() {    this.slides.autoplayDisableOnInteraction = false; //禁止slider拖动后autoPlay失效  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hybird App </tag>
            
            <tag> Ionic 3 </tag>
            
            <tag> Angular 4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复 Ionic 3.0.1 在IOS点击Tabs多次出现黑屏问题方法</title>
      <link href="/2017/04/11/ionic/ios-blackscreen-fix.html"/>
      <url>/2017/04/11/ionic/ios-blackscreen-fix.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Ionic 3.0.1 在IOS存在的一个严重的BUG，在IOS下多次重复点击TAB的时候页面会出现黑屏问题。</p></blockquote><blockquote><p>好消息是目前有一个暂时的修复方法。但是这个方法涉及修改Ionic核心代码，所以如果你们正在使用Ionic3发布APP，可以暂时使用以下办法修复问题。</p></blockquote><blockquote><p>在<code>node_modules/ionic-angular/components/tabs/tabs.js</code>找到一下代码 (468行)</p></blockquote><pre><code class="typescript">getComponent(this._linker, tab.root).then(function (viewController) {    if (viewController !== active.component) {        // Otherwise, if the page we&#39;re on is not our real root        // reset it to our default root type        return tab.setRoot(tab.root);    }}).catch(function () {    (void 0) /* console.debug */;});</code></pre><blockquote><p>把以上代码改为</p></blockquote><pre><code class="typescript">getComponent(this._linker, tab.root).then(function (viewController) {    if (viewController.component !== active.component) {        // Otherwise, if the page we&#39;re on is not our real root        // reset it to our default root type        return tab.setRoot(tab.root);    }}).catch(function () {    (void 0) /* console.debug */;});</code></pre><blockquote><p>以上解决办法来自于github上面的一个大神 <a href="https://github.com/driftyco/ionic/pull/11084" target="_blank" rel="noopener">https://github.com/driftyco/ionic/pull/11084</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hybird App </tag>
            
            <tag> Ionic 3 </tag>
            
            <tag> Angular 4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 升级 3 教程</title>
      <link href="/2017/04/10/ionic/upgrade-guide.html"/>
      <url>/2017/04/10/ionic/upgrade-guide.html</url>
      
        <content type="html"><![CDATA[<h2 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h2><blockquote><p>这一次的升级Ionic 3 换成了使用最新的Angular 4.0, 最新的TypeScript, 添加了懒加载和修复了一些组件的bug.</p></blockquote><ol><li>首先更新<code>package.json</code>, 按照以下的代码相应替换你package.json里面的代码, 并且把你项目根目录下的<code>node_modules</code>文件夹删除掉, 然后运行<code>npm install</code> (如果你是用淘宝镜像可以运行 <code>cnpm install</code>)</li></ol><pre><code class="json">&quot;dependencies&quot;: {    &quot;@angular/common&quot;: &quot;4.0.0&quot;,    &quot;@angular/compiler&quot;: &quot;4.0.0&quot;,    &quot;@angular/compiler-cli&quot;: &quot;4.0.0&quot;,    &quot;@angular/core&quot;: &quot;4.0.0&quot;,    &quot;@angular/forms&quot;: &quot;4.0.0&quot;,    &quot;@angular/http&quot;: &quot;4.0.0&quot;,    &quot;@angular/platform-browser&quot;: &quot;4.0.0&quot;,    &quot;@angular/platform-browser-dynamic&quot;: &quot;4.0.0&quot;,    &quot;@ionic-native/core&quot;: &quot;3.4.2&quot;,    &quot;@ionic-native/splash-screen&quot;: &quot;3.4.2&quot;,    &quot;@ionic-native/status-bar&quot;: &quot;3.4.2&quot;,    &quot;@ionic/storage&quot;: &quot;2.0.1&quot;,    &quot;ionic-angular&quot;: &quot;3.0.1&quot;,    &quot;ionicons&quot;: &quot;3.0.0&quot;,    &quot;rxjs&quot;: &quot;5.1.1&quot;,    &quot;sw-toolbox&quot;: &quot;3.4.0&quot;,    &quot;zone.js&quot;: &quot;^0.8.4&quot;},&quot;devDependencies&quot;: {  &quot;@ionic/app-scripts&quot;: &quot;1.3.0&quot;,  &quot;typescript&quot;: &quot;~2.2.1&quot;}</code></pre><ol start="2"><li>第二步你需要在<code>app/app.module.ts</code>文件里面引入<code>BrowserModule</code>和<code>HttpModule</code></li></ol><blockquote><p>首先需要在头部引入这两个module (如果你的APP不使用HTTP可以不引入<code>HttpModule</code>)</p></blockquote><pre><code class="typescript">import { BrowserModule } from &#39;@angular/platform-browser&#39;;import { HttpModule } from &#39;@angular/http&#39;;</code></pre><blockquote><p>在同一个文件里面找到<code>imports</code>并且加入<code>BrowserModule</code>和<code>HttpModule</code></p></blockquote><pre><code class="typescript">imports: [  BrowserModule,  HttpModule,  IonicModule.forRoot(MyApp)],</code></pre><ol start="3"><li>如果你升级到 Ionic Native 3.x, 就是CLI3. 使用 Ionic Native 3.x的话, APP打包出来会更小. 因为Ionic Native的原生插件都不自带有了, 你使用一个就要安装一个. 如果你原有的Ionic 2 项目有引入原生插件, 你就要做以下操作.</li></ol><blockquote><p>这里用<code>Camera</code>和<code>Geolocation</code>这个两个原生插件作为例子, 你其他的插件都需要使用相同的方式做修改</p></blockquote><blockquote><p>注意您使用的所有插件都必须要在<code>app/app.module.ts</code>里面先引用了, 而且要在<code>app/app.modules.ts</code>里面的providers里面声明, 如果没有这样配置就会出现<code>No provider for XXXXX</code>这样的报错了!</p></blockquote><h4 id="Camera插件"><a href="#Camera插件" class="headerlink" title="Camera插件"></a>Camera插件</h4><pre><code class="typescript">// 在app/app.module.ts文件里面import { Camera } from &#39;@ionic-native/camera&#39;;...@NgModule({  ...  providers: [    ...    Camera    ...  ]  ...})export class AppModule { }</code></pre><h4 id="Geolocation插件"><a href="#Geolocation插件" class="headerlink" title="Geolocation插件"></a>Geolocation插件</h4><pre><code class="typescript">// 在app/app.module.ts文件里面import { Geolocation } from &#39;@ionic-native/geolocation&#39;;import { Platform } from &#39;ionic-angular&#39;;import { NgZone } from &#39;@angular/core&#39;;@Component({ ... })export class MyComponent {  constructor(private geolocation: Geolocation, private platform: Platform, private ngZone: NgZone) {    platform.ready().then(() =&gt; {      // get position      geolocation.getCurrentPosition().then(pos =&gt; {        console.log(`lat: ${pos.coords.latitude}, lon: ${pos.coords.longitude}`)      });      // watch position      const watch = geolocation.watchPosition().subscribe(pos =&gt; {        console.log(`lat: ${pos.coords.latitude}, lon: ${pos.coords.longitude}`)        // Currently, observables from Ionic Native plugins        // need to run inside of zone to trigger change detection        ngZone.run(() =&gt; {          this.position = pos;        })      });      // to stop watching      watch.unsubscribe();    });  }}</code></pre><blockquote><p>更详细的文档可以参考官方的修改日记 <a href="https://github.com/driftyco/ionic-native/blob/master/README.md" target="_blank" rel="noopener">https://github.com/driftyco/ionic-native/blob/master/README.md</a></p></blockquote><h2 id="组件Component更变"><a href="#组件Component更变" class="headerlink" title="组件Component更变"></a>组件<code>Component</code>更变</h2><h4 id="新网格"><a href="#新网格" class="headerlink" title="新网格"></a>新网格</h4><blockquote><p>旧的网格体系已经废除, 新的网格组件请参考官方文档 <a href="http://blog.ionic.io/build-awesome-desktop-apps-with-ionics-new-responsive-grid/" target="_blank" rel="noopener">http://blog.ionic.io/build-awesome-desktop-apps-with-ionics-new-responsive-grid/</a></p></blockquote><h4 id="标签的color属性更变"><a href="#标签的color属性更变" class="headerlink" title="标签的color属性更变"></a>标签的<code>color</code>属性更变</h4><blockquote><p>以下标签的<code>color</code>属性在新的版本里面会不起效果了, 现在必须要使用<code>ion-text</code>才会起效果, 详细说明请看官方文档 <a href="http://ionicframework.com/docs/api/components/typography/Typography/" target="_blank" rel="noopener">http://ionicframework.com/docs/api/components/typography/Typography/</a></p></blockquote><pre><code class="css">h1[color], h2[color], h3[color], h4[color], h5[color], h6[color], a[color]:not([ion-button]):not([ion-item]):not([ion-fab]), p[color], span[color], b[color], i[color], strong[color], em[color], small[color], sub[color], sup[color]</code></pre><h4 id="Slides组件更变"><a href="#Slides组件更变" class="headerlink" title="Slides组件更变"></a>Slides组件更变</h4><blockquote><p>以下的Slides属性和方法已经正式在新版本里面移除了</p></blockquote><ul><li>Slides的input的<code>options</code>属性已经废除, 请使用标签的属性;</li><li>Slide的事件<code>ionWillChange</code>方法已经废除, 请使用<code>ionSlideWillChange</code>;</li><li>Slide的事件<code>ionDidChange</code>方法已经废除, 请使用<code>ionSlideDidChange</code>;</li><li>Slide的事件<code>ionDrag</code>方法已经废除, 请使用<code>ionSlideDrag</code>;</li><li>Slides的<code>getSlider()</code>方法已经废除, 请使用<code>ion-slides</code>实例;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hybird App </tag>
            
            <tag> Ionic 3 </tag>
            
            <tag> Angular 4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 - 确认密码</title>
      <link href="/2017/03/19/ionic/comfirm-password-validators.html"/>
      <url>/2017/03/19/ionic/comfirm-password-validators.html</url>
      
        <content type="html"><![CDATA[<p>开发过程中一般在注册或者修改密码都要写一个密码确认的表格, 这篇文章就是记录怎么在Ionic2里面使用<strong>FormBuilder</strong>和<strong>Validators</strong>判断密码是否一致.</p><p>首先这篇文章是默认您已经了解怎么使用<strong>Angualr2</strong>的<strong>FormBuilder</strong>和<strong>Validator</strong>, 如果你还没了解这两个类的用法可以前去看<a href="https://ionicframework.com/docs/v2/resources/forms/" target="_blank" rel="noopener">Ionic2的文档</a></p><h1 id="实例一个FormGroup"><a href="#实例一个FormGroup" class="headerlink" title="实例一个FormGroup"></a>实例一个<code>FormGroup</code></h1><blockquote><p>第一步首先我们需要实例了FormBuilder的一个FormGroup</p></blockquote><ul><li>这里我们定义了passwordForm的这个表格里面的input.</li><li>在最后我们加入了自定义认证方法 { validator: AdvanceValidator.matchingPasswords(‘password’, ‘rePassword’) }</li><li>这里我们把password, 和rePassword 传给了 AdvanceValidator 方法, 这里传的是密码和确认密码在FormGroup里面定义的名字.</li><li>现在我们看看这个password.ts怎么写.</li></ul><pre><code class="typescript">import { FormBuilder, Validators, FormGroup } from &#39;@angular/forms&#39;;import { AdvanceValidator } from &#39;../../validators/advance-validator&#39;;@Component({  selector: &#39;page-password&#39;,  templateUrl: &#39;password.html&#39;})//密码修改页export class PasswordPage {  passwordForm: FormGroup;  constructor(private fb: FormBuilder)   {    this.passwordForm = fb.group({        username: [&#39;&#39;, Validators.required],        password: [&#39;&#39;, Validators.compose([Validators.maxLength(30), Validators.minLength(7), Validators.required])],        rePassword: [&#39;&#39;, Validators.compose([Validators.maxLength(30), Validators.minLength(7), Validators.required])],    }, { validator: AdvanceValidator.matchingPasswords(&#39;password&#39;, &#39;rePassword&#39;) });  }}</code></pre><h1 id="创建自定义认证器"><a href="#创建自定义认证器" class="headerlink" title="创建自定义认证器"></a>创建自定义认证器</h1><ul><li>我们首先在项目根目录创建 <strong>validators</strong> 的文件夹</li><li>然后在里面创建 <strong>advance-validators.ts</strong> 的ts文件</li><li>在 <strong>advance-validators.ts</strong> 里面编以下代码</li></ul><pre><code class="typescript">import { FormGroup } from &#39;@angular/forms&#39;;export class AdvanceValidator {    static matchingPasswords(passwordKey: string, rePasswordKey: string) {    return (group: FormGroup) =&gt; {      let password = group.controls[passwordKey]; //获取密码值      let rePassword = group.controls[rePasswordKey]; //获取确认密码值      if(password.value !== rePassword.value) {        //如果密码和确认密码的值不一致就返回给FormBuild rePassword有错误        return rePassword.setErrors({notEquivalent: true})       }    }  }}</code></pre><h1 id="前端表格示例"><a href="#前端表格示例" class="headerlink" title="前端表格示例"></a>前端表格示例</h1><pre><code class="html">&lt;form [formGroup] = &quot;passwordForm&quot;&gt;  &lt;ion-list inset&gt;    &lt;ion-item&gt;      &lt;ion-input type=&quot;tel&quot; placeholder=&quot;用户名&quot; formControlName=&quot;username&quot;&gt;&lt;/ion-input&gt;      &lt;div item-right *ngIf=&quot;!passwordForm.controls.username.valid  &amp;&amp; (passwordForm.controls.username.dirty)&quot;&gt;        &lt;ion-icon name=&quot;alert&quot;&gt;&lt;/ion-icon&gt; 用户名必填      &lt;/div&gt;    &lt;/ion-item&gt;    &lt;ion-item&gt;      &lt;ion-input type=&quot;password&quot; placeholder=&quot;新密码&quot; formControlName=&quot;password&quot;&gt;&lt;/ion-input&gt;      &lt;div item-right *ngIf=&quot;!passwordForm.controls.password.valid  &amp;&amp; (passwordForm.controls.password.dirty)&quot; &gt;        &lt;ion-icon name=&quot;alert&quot;&gt;&lt;/ion-icon&gt; 密码必须7个字以上      &lt;/div&gt;    &lt;/ion-item&gt;    &lt;ion-item&gt;      &lt;ion-input type=&quot;password&quot; placeholder=&quot;确认密码&quot; formControlName=&quot;rePassword&quot;&gt;&lt;/ion-input&gt;      &lt;div item-right *ngIf=&quot;!passwordForm.controls.rePassword.valid  &amp;&amp; (passwordForm.controls.rePassword.dirty)&quot; &gt;        &lt;ion-icon name=&quot;alert&quot;&gt;&lt;/ion-icon&gt; 密码必须一致      &lt;/div&gt;    &lt;/ion-item&gt;  &lt;/ion-list&gt;&lt;/form&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ionic 2 </tag>
            
            <tag> Angular 2 </tag>
            
            <tag> Hybird App </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel 5.4 开发笔记</title>
      <link href="/2017/02/26/laravel/laravel5.4-passport-and-authen.html"/>
      <url>/2017/02/26/laravel/laravel5.4-passport-and-authen.html</url>
      
        <content type="html"><![CDATA[<p>Laravel最近出的Laravel5.4新加了挺多功能的, 比起我用了1年的5.1完善多了. 比较吸引我使用最新的5.4的有几点:</p><ul><li>5.4 添加了谷歌内核的浏览器模拟操作</li><li>自带API认证类”PASSPORT”</li><li>路由自动分类, 现有有了Route自己的文件夹然后里面分类好了WEB和API的路由<br>这一篇记录会分享一些我在尝试Laravel 5.4的过程中遇到的问题和经验</li></ul><h2 id="开发记录"><a href="#开发记录" class="headerlink" title="开发记录"></a>开发记录</h2><h3 id="移植-Migrate-用户和API认证表格是出现sql错误"><a href="#移植-Migrate-用户和API认证表格是出现sql错误" class="headerlink" title="移植(Migrate)用户和API认证表格是出现sql错误"></a>移植(Migrate)用户和API认证表格是出现sql错误</h3><pre><code class="console">[Illuminate\Database\QueryException]                                                           SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key     length is 767 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`))   </code></pre><pre><code class="console">[PDOException]                                                                                 SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key     length is 767 bytes  </code></pre><p>解决办法就是在<strong>app/Providers/AppServiceProvider.php</strong>的这个文件里面的<strong>boot</strong>方法里面添加一下代码:</p><pre><code class="php">use Illuminate\Support\Facades\Schema;function boot(){    Schema::defaultStringLength(191);}</code></pre><h3 id="怎么不使用Laravel5-4自带的用户登录字段"><a href="#怎么不使用Laravel5-4自带的用户登录字段" class="headerlink" title="怎么不使用Laravel5.4自带的用户登录字段"></a>怎么不使用Laravel5.4自带的用户登录字段</h3><p>每次使用laravel自带的用户认证体系都会纠结, 怎么不用它自带的email作为用户名!<br>这次适用Laravel5.4 又遇到了这个问题, 而且解决办法和5.1,5.2的不一样了, 因为Laravel的Auth Provider变动了.<br>解决办法就是在自带的<strong>User.php</strong>(用户模型)里面使用<strong>findForPassport</strong>, 参考一下例子:</p><pre><code class="php">class User extends Authenticatable{    use HasApiTokens, Notifiable;    // ... some code    public function findForPassport($username) {        return $this-&gt;where(&#39;id&#39;, $username)-&gt;first();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel 5.4 </tag>
            
            <tag> Laravel Passport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 开发笔记</title>
      <link href="/2017/02/25/ionic/dev-note.html"/>
      <url>/2017/02/25/ionic/dev-note.html</url>
      
        <content type="html"><![CDATA[<p>因为IONIC2才刚刚开始进入正式版, 中文文档基本都是不全的, 我现在开发都是在看英文文档<br>在开发的过程中遇到了很多文档没有描述的问题, 而且开发的过程中遇到一些框架本身没有完善的功能和存在的BUG</p><p>我会在这个日记里面记录一些文档没有写的, 和我开发过程中遇到的一些坑和经验, 希望可以帮助那些刚刚接触IONIC2的程序猿们!</p><h2 id="APP配置"><a href="#APP配置" class="headerlink" title="APP配置"></a>APP配置</h2><h3 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h3><p>因为跨域问题，在开发时如果要用到本地环境进行开发(ionic serve)，必须配置proxy</p><ul><li>Proxy位于项目根目录下的 <strong>ionic.config.json</strong></li></ul><ul><li>只需要把<strong>proxyUrl</strong>改为你本地环境的API地址</li></ul><pre><code class="javascript">{  &quot;name&quot;: &quot;rlph&quot;,  &quot;app_id&quot;: &quot;&quot;,  &quot;v2&quot;: true,  &quot;typescript&quot;: true,  &quot;proxies&quot;: [    {      &quot;path&quot;: &quot;/api&quot;,      &quot;proxyUrl&quot;: &quot;http://api.dev&quot;    }  ]}</code></pre><ul><li>然后把API地址的常量制定为<strong>/api/</strong>这个proxy</li></ul><ul><li>在根目录下<strong>/src/config.ts</strong>里面把<strong>“API_SERVER”</strong>的值改为<strong>“/api/“</strong></li></ul><pre><code>  export let data = {      &quot;API_SERVER&quot; : &quot;/api/&quot;  }</code></pre><h3 id="上线APP配置"><a href="#上线APP配置" class="headerlink" title="上线APP配置"></a>上线APP配置</h3><ul><li>首先你需要配置真是服务器API地址<br>配置API地址是在根目录下<strong>/src/config.ts</strong>里面把<strong>“API_SERVER”</strong>的值改为线上API地址</li></ul><pre><code>  export let data = {      &quot;API_SERVER&quot; : &quot;http://api.domain.com/&quot;  }</code></pre><h2 id="开发常见问题"><a href="#开发常见问题" class="headerlink" title="开发常见问题"></a>开发常见问题</h2><h3 id="APP-run-失败"><a href="#APP-run-失败" class="headerlink" title="APP run 失败"></a>APP run 失败</h3><p>当运行<strong>ionic run android</strong>的时候可能会遇到该报错：</p><pre><code>Error: Failed to install apk to device: [  1%] /data/local/tmp/android-debug.apk[  2%] /data/local/tmp/android-debug.apk...[100%] /data/local/tmp/android-debug.apk        pkg: /data/local/tmp/android-debug.apkFailure [INSTALL_FAILED_UPDATE_INCOMPATIBLE]</code></pre><ul><li>此问题是因为已有签名的APP存在手机上， 需要想删除该APP才能安装测试（debug）版的apk</li><li>在cmd运行以下代码即可解决问题：</li></ul><pre><code>adb uninstall my.package.id</code></pre><h3 id="Ionic-2-自带的native文件上传-FILE-TRANSFER-插件无法获取成功返回内容"><a href="#Ionic-2-自带的native文件上传-FILE-TRANSFER-插件无法获取成功返回内容" class="headerlink" title="Ionic 2 自带的native文件上传(FILE TRANSFER)插件无法获取成功返回内容"></a>Ionic 2 自带的native文件上传(FILE TRANSFER)插件无法获取成功返回内容</h3><p>这个是Ionic 2 核心代码里面的一个BUG, 在一下版本下是有问题的<br><strong>Ionic CLI Version: 2.2.1</strong></p><ul><li>首先找到项目根目录下以下路径里面的<strong>filetransfer.d.ts</strong>文件</li></ul><pre><code>node_modules\ionic-native\dist\es5\plugins\filetransfer.d.tsnode_modules\ionic-native\dist\esm\plugins\filetransfer.d.ts</code></pre><ul><li>分别修改以上两个文件里面的代码</li></ul><pre><code>//把这一行:upload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise&lt;FileUploadResult | FileTransferError&gt;//改为: upload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise&lt;FileUploadResult&gt;</code></pre><h3 id="在安卓下使用相册选择时-返回的图片路径不能再显示问题"><a href="#在安卓下使用相册选择时-返回的图片路径不能再显示问题" class="headerlink" title="在安卓下使用相册选择时, 返回的图片路径不能再显示问题"></a>在安卓下使用相册选择时, 返回的图片路径不能再显示问题</h3><ul><li>首先在这个例子使用的是cordova-plugin-camera组件(Cordova的相机插件)</li><li>首先引入需要的类</li><li>FilePath 这个类就是用来修复安卓上图片URI的问题的</li></ul><pre><code class="typescript">import { Camera, File, FilePath } from &#39;ionic-native&#39;;</code></pre><ul><li>使用 FilePath.resolveNativePath(imagePath) 这个方法来纠正图片URI</li></ul><pre><code class="typescript">Camera.getPicture(options).then((imagePath) =&gt; { // 特殊安卓图片库的处理 this.nativeFilePath = imagePath; if (this.pl.is(&#39;android&#39;) &amp;&amp; sourceType === Camera.PictureSourceType.PHOTOLIBRARY) {   FilePath.resolveNativePath(imagePath)   .then(filePath =&gt; {       this.nativeFilePath = filePath;       let currentName = imagePath.substring(imagePath.lastIndexOf(&#39;/&#39;) + 1, imagePath.lastIndexOf(&#39;?&#39;));   }); } else {   var currentName = imagePath.substr(imagePath.lastIndexOf(&#39;/&#39;) + 1); }}, err =&gt; { // this.presentToast(&#39;选择图片失败.&#39;);});</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ionic 2 </tag>
            
            <tag> Angular 2 </tag>
            
            <tag> Hybird App </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
