
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>力扣实战之移动零、盛最多的水、爬楼梯 - 三·钻 TriDiamond</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    <meta name="description" content="练题法则5-10 分钟读题与思考

不要纠结没有思路就直接看题解；
不要死磕觉得自己很失败，怎么我们就想不出来；
基本上这些算法题，让我们自己想出来是不可能的；
拿跳表的来说，如果我们能从 0-1 ,"> 
    <meta name="author" content="三·钻 TriDiamond"> 
    <link rel="alternative" href="atom.xml" title="三·钻 TriDiamond" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

<meta name="generator" content="Hexo 4.2.1"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">三·钻 TriDiamond</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://tridiamond.me">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">力扣实战之移动零、盛最多的水、爬楼梯</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(https://img-blog.csdnimg.cn/20200716163259937.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/Algorithm"><b>「
                    </b>ALGORITHM<b> 」</b></a>
                
                六月 24, 2020
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2020/06/24/algorithm/leetcode-moveZero-water-stairs.html" title="力扣实战之移动零、盛最多的水、爬楼梯" class="">力扣实战之移动零、盛最多的水、爬楼梯</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    16k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    15 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="练题法则"><a href="#练题法则" class="headerlink" title="练题法则"></a>练题法则</h1><p><strong>5-10 分钟读题与思考</strong></p>
<ul>
<li><strong>不要纠结</strong>没有思路就直接看题解；</li>
<li><strong>不要死磕</strong>觉得自己很失败，怎么我们就想不出来；</li>
<li>基本上这些算法题，让我们自己想出来是不可能的；</li>
<li>拿跳表的来说，如果我们能从 0-1 把它想出来，那我们就可以拿到图灵奖了；</li>
<li>所以记住！<strong>无思路就直接看题解，无思路就直接看题解，无思路就直接看题解</strong>！</li>
<li>我们只需要<strong>知道并且能运用即可！</strong></li>
</ul>
<p><strong>有思路</strong></p>
<ul>
<li>自己开始写代码，没有，就马上看题解！<br><strong>默写背题，熟练</strong></li>
<li>做完题目后，我们需要记住这种题的思路和有<strong>N 种解决办法</strong>；</li>
<li>重复再<strong>重复的默写，</strong>直到自己有深刻的影响；</li>
</ul>
<p><strong>最后开始自己写（闭卷）</strong></p>
<ul>
<li>到了这里如果我们还需要看别人代码，那就要回去背题；</li>
<li>能到达这个阶段基本这种题你已经开始熟悉的，接下来就是反复练习；</li>
</ul>
<h2 id="在哪里练题？"><a href="#在哪里练题？" class="headerlink" title="在哪里练题？"></a>在哪里练题？</h2><p>那肯定是<a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣</a>了！没有账号的小伙伴，马上就去注册个账号开始日复一日的练习吧！～</p>
<p><img src="https://img-blog.csdnimg.cn/20200613135642518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""></p>
<h1 id="283-题-移动零"><a href="#283-题-移动零" class="headerlink" title="283 题 - 移动零"></a>283 题 - 移动零</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a>｜<strong>难度</strong>：<font color="green">简单</font></p>
</blockquote>
<h2 id="题目讲解"><a href="#题目讲解" class="headerlink" title="题目讲解"></a>题目讲解</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例：</p>
<pre><code>输入: [0,1,0,3,12]
输出: [1,3,12,0,0]</code></pre><p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<p><strong>这里需要注意的重点：</strong></p>
<ol>
<li>所有 <code>0</code> 移动到数组的末尾；</li>
<li>保持非零元素的相对顺序；</li>
<li>必须在原数组上操作，不能拷贝额外的数组；</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>思考题解时，使用<strong>MECE 原则</strong> — 每一个思路都相对独立的思维，然后想到完全穷尽。首先不要管附加条件，先把有可能解决这个问题的思路都想出来，再评估哪一个办法是最优解。面试的时候也是一样，说出你所有可以想到的思路，然后分别讲出各自的优点与缺点，最后提出最优答案。</p>
</blockquote>
<ol>
<li><strong>统计 0 的个数</strong><ul>
<li>循环数组找到 0 的位置，遇到 0 就为 0 的个数加一；</li>
<li>遇到不是 0 的时候，把非 0 的元素值与 0 的元素交换即可；</li>
</ul>
</li>
<li><strong>开新数组</strong><ul>
<li>给一个指针<code>i</code>从数组的头部开始递增；</li>
<li>给一个指针<code>j</code>从数组的尾部开始递减（也就是原数组的总长度）；</li>
<li>遇到零就往<code>j</code>指针的位置放，然后<code>j--</code>；</li>
<li>遇到非零就往<code>i</code>指针的位置放，然后<code>i++</code>；</li>
<li><strong>缺点：</strong>内存使用会高；</li>
<li><strong>不符合条件：</strong>必须在原数组上操作，所以可以实现但是不符合条件；</li>
</ul>
</li>
<li><strong>双指针交换</strong><ul>
<li>给两个指针<code>i</code>和<code>j</code>，并且默认都从 0 开始；</li>
<li><code>i</code>指向的是当前位置；</li>
<li><code>j</code>指针会一直移动，直到找到一个非零元素，然后与<code>i</code>位置的值交换；</li>
<li>如果<code>j</code>的位置与<code>i</code>不是一致的话，就可以给<code>j</code>的值换成 0；</li>
</ul>
</li>
<li><strong>双指针替换后清零</strong><ul>
<li>这个与<strong>第三种</strong>方法一致，也是双指针；</li>
<li>唯一的区别是不在<code>i</code>指针扫描的时候替换零；</li>
<li>而是在替换完毕所有非零元素后，把剩余的全部位数都改为 0；</li>
</ul>
</li>
</ol>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><p><strong>「方法一」</strong> - 统计 0 的个数：</p>
<ul>
<li>时间复杂度：$O(n)$ - N 个元素就需要遍历 N 次</li>
<li>空间复杂度：$O(1)$ - 只对原数组进行替换操作</li>
</ul>
<pre><code class="javascript">/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let zeroCount = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] == 0) {
      zeroCount += 1;
    } else if (zeroCount &gt; 0) {
      nums[i - zeroCount] = nums[i];
      nums[i] = 0;
    }
  }
};</code></pre>
<p><strong>「方法二」</strong> - 双指针交换：</p>
<p><img src="https://img-blog.csdnimg.cn/20200624213737392.gif#pic_center" alt=""></p>
<ul>
<li>时间复杂度：$O(n)$ - N 个元素就需要遍历 N 次</li>
<li>空间复杂度：$O(1)$ - 只对原数组进行替换操作</li>
</ul>
<pre><code class="javascript">/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let j = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] !== 0) {
      nums[j] = nums[i];
      if (j !== i) {
        nums[i] = 0;
      }
      j++;
    }
  }
};</code></pre>
<p><strong>「方法三」</strong> - 双指针替换后清零：</p>
<p><img src="https://img-blog.csdnimg.cn/20200624213755998.gif#pic_center" alt=""></p>
<ul>
<li>时间复杂度：$O(n)$ - N 个元素就需要遍历 N 次，加上最后清零是走了<code>n减非零的个数</code>，那就是<code>O(n+n-i)</code>，总的来说还是<code>O(n)</code></li>
<li>空间复杂度：$O(1)$ - 只对原数组进行替换操作</li>
</ul>
<pre><code class="javascript">/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  var j = 0;
  for (let i = 0; i &lt; nums.length; i++) {
    if (nums[i] != 0) {
      nums[j] = nums[i];
      j++;
    }
  }

  for (let k = j; k &lt; nums.length; k++) {
    nums[k] = 0;
  }
};</code></pre>
<h2 id="边界测试用例"><a href="#边界测试用例" class="headerlink" title="边界测试用例"></a>边界测试用例</h2><blockquote>
<p>[0,1,0,3,12][1,2] &gt; [0,0]</p>
</blockquote>
<h2 id="题解对比与分析"><a href="#题解对比与分析" class="headerlink" title="题解对比与分析"></a>题解对比与分析</h2><blockquote>
<p><strong>注意</strong>：以下数据都是在<strong>力扣</strong>中提交后返回的结果，每次提交都有可能不一致。所以相近的方案输出的结果有所差异也是正常的，最终<strong>最优方案要通过分析代码来确定</strong>，<strong>不能只以力扣输出的数据为准，只能供于我们作为参考</strong>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>执行时间</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody><tr>
<td>「方法一」- 统计 0 的个数</td>
<td>96 ms（战胜 17.82%）</td>
<td>37.1 MB</td>
</tr>
<tr>
<td>「方法二」- 双指针交换</td>
<td>72 ms（战胜 87.23%）</td>
<td>37.2 MB</td>
</tr>
<tr>
<td>「方法三」- 双指针替换后清零</td>
<td>76 ms（战胜 73.98%）</td>
<td>37.2 MB</td>
</tr>
</tbody></table>
<p><strong>分析一下：</strong></p>
<ul>
<li>第一种方法是通过统计 0 出现的次数来定位到需要替换 0 的所在位置，里面涉及一个<code>i - zeroCount</code>的运算，所以相对其他方法来说运行时间会更长一些；</li>
<li>第二个方法是通过两个指针一起运行，一个固定在 0 元素，一个一直走找到非 0 元素，最后做一个交换，这种方法没有涉及运算，同时也是一个循环就可以完成，相对来说是最优解；</li>
<li>第三种方法也是用了双指针，与第二种方法的唯一区别就是先替换掉所有 0 的元素，最后把剩余的元素全部一次性替换成 0。可读性来说，个人觉得更容易懂，但是时间和空间复杂度和第二种方法是一致的。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200613135642518.png" alt=""></p>
<h1 id="11-题-盛最多水的容器"><a href="#11-题-盛最多水的容器" class="headerlink" title="11 题 - 盛最多水的容器"></a>11 题 - 盛最多水的容器</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">283. 盛最多水的容器</a>｜<strong>难度</strong>：<font color="orange">中等</font></p>
</blockquote>
<h2 id="题目讲解-1"><a href="#题目讲解-1" class="headerlink" title="题目讲解"></a>题目讲解</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<blockquote>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200624214839464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>
</blockquote>
<p><strong>题目重点：</strong></p>
<ol>
<li>首先我们的目标是挑选两条柱子，从而让两个柱子之前可以得出最大的面积（面积越大自然可容纳的水就越多）；</li>
<li>挑选最长的两个柱子不等于拥有最大的面积，因为它们之间的距离也是决定空间的一个维度；</li>
<li>所以重点是找到高度和宽度比例最大的一对柱子，从而得出最大面积；</li>
<li>注意在运算面积时，我们只能用一对柱子中最短的一条作为高度，因为水只能填满到最短的那条柱子的高度；</li>
<li>面积运算公式： <code>高度 x 宽度 = 面积</code></li>
</ol>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p><strong>枚举</strong> —— 暴力解法</p>
<ul>
<li>遍历左边和右边，找出所有面积；</li>
<li>列出所有柱子的组合；</li>
<li>算出所有组合各自的面积；</li>
<li>最后输出最大的面积的一组；</li>
<li><strong>缺点：</strong>遍历次数过高，所以时间复杂度会相对偏高</li>
<li><strong>复杂度</strong>：时间复杂度 $O(n^2)$、空间复杂度 $O(1)$</li>
</ul>
</li>
<li><p><strong>双指针</strong></p>
<ul>
<li><p>左右两边都往中间移动；</p>
</li>
<li><p>需要移动左右两头的问题都可以考虑双指针；</p>
</li>
<li><p>相同情况下两遍距离越远越好；</p>
</li>
<li><p>区域受限于较短边的高度；</p>
</li>
<li><p>所以让较矮的那边的指针往内移动；</p>
</li>
<li><p>一直以上面的规则移动知道两个指针重合；</p>
</li>
</ul>
</li>
</ol>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><p><strong>「方法一」</strong> - 枚举（暴力破解）：</p>
<ul>
<li>时间复杂度：$O(n^2)$ - 双循环，所以总计循环了 N^2。</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="javascript">/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
  let max = 0;
  for (let i = 0; i &lt; height.length - 1; i++) {
    for (let j = i + 1; j &lt; height.length; j++) {
      let area = (j - i) * Math.min(height[i], height[j]);
      max = Math.max(max, area);
    }
  }
  return max;
};</code></pre>
<p><strong>「方法二」</strong> - 双指针：</p>
<ul>
<li>时间复杂度：$O(n)$ - 双指针总计最多遍历整个数组一次。</li>
<li>空间复杂度：$O(1)$ - 只需要额外的常数级别的空间。</li>
</ul>
<pre><code class="javascript">/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
  let max = 0;

  for (let i = 0, j = height.length - 1; i &lt; j; ) {
    let minHeight = height[i] &lt; height[j] ? height[i++] : height[j--];
    let area = (j - i + 1) * minHeight;
    max = Math.max(max, area);
  }

  return max;
};</code></pre>
<h2 id="题解对比与分析-1"><a href="#题解对比与分析-1" class="headerlink" title="题解对比与分析"></a>题解对比与分析</h2><table>
<thead>
<tr>
<th>方法</th>
<th>执行时间（毫秒）</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody><tr>
<td>枚举（暴力破解）</td>
<td>984 ms （战胜 9.99%）</td>
<td>35.9 MB</td>
</tr>
<tr>
<td>双指针</td>
<td>56 ms（战胜 99.88%）</td>
<td>36 MB</td>
</tr>
</tbody></table>
<p><strong>分析一下</strong></p>
<ul>
<li>通过使用第二种方法，我们从$O(n^2)$的时间复杂度降到$O(n)$，总的执行时间大概是<strong>快了 17 倍</strong>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200613135642518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RyaURpYW1vbmQ2,size_16,color_FFFFFF,t_70" alt=""></p>
<h1 id="70-题-爬楼梯"><a href="#70-题-爬楼梯" class="headerlink" title="70 题 - 爬楼梯"></a>70 题 - 爬楼梯</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">283. 移动零</a>｜<strong>难度</strong>：<font color="green">简单</font></p>
</blockquote>
<h2 id="题目讲解-2"><a href="#题目讲解-2" class="headerlink" title="题目讲解"></a>题目讲解</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<blockquote>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
</blockquote>
<h3 id="题解重点"><a href="#题解重点" class="headerlink" title="题解重点"></a>题解重点</h3><p>其实题目本身并不难，在力扣（LeetCode）是属于“简单”级别的题目，但是如果没有思路，或者对这个题目完全不了解的话，一点头绪都没有也是正常的，这种题目也就是<strong>属于套路题</strong>。如果我们是不知道的话，我们自然会难到不知道怎么做。我们要是知道了的话，那就变得相当容易了。</p>
<p>这里讲一下解题的思想：</p>
<blockquote>
<p><strong>首先我们解题时最大的误区是什么？</strong></p>
<ul>
<li>做题只做了一遍</li>
<li>至少要做五遍</li>
</ul>
<p><strong>然后我们优化的思想是什么？</strong></p>
<ul>
<li>空间换时间</li>
<li>升维思想（升级到二维）</li>
</ul>
<p><strong>看题时懵了怎么办？</strong></p>
<ul>
<li>首先我们能不能暴力破解？</li>
<li>最基本的情况我们应该怎么解决？能否化繁为简？</li>
</ul>
<p><strong>破解所有问题的法则：</strong></p>
<ul>
<li><strong>找最近重复的子问题</strong></li>
<li>为什么？因为写程序我们只能写<code>if</code>，<code>else</code>，<code>for</code>，<code>while</code>，<code>recursion</code>（递归）</li>
<li>计算机是人类发明的，计算机肯定是没有人脑那么强的，它其实就是一个<strong>简单的重复式机器</strong></li>
<li>那么计算机运行的程序也是同理，它是用重复的东西来解决问题的</li>
<li>如果我们遇到算法题的时候，就是需要我们用程序去解决的问题，那<strong>问题的本身就是可重复的</strong></li>
<li>无论是算法中的回述、分治、动态规划、递归等，全部都是在<strong>找重复性</strong>的原理</li>
<li>所以重点都是“<strong>找规律</strong>”</li>
</ul>
</blockquote>
<h3 id="深度分析题目："><a href="#深度分析题目：" class="headerlink" title="深度分析题目："></a>深度分析题目：</h3><p>首先我们使用<strong>化繁为简</strong>的思维来分析：</p>
<p>要到达第一个台阶，我们只能爬 1 个台阶，所以只有一种方法的可能性，所以 n = 1 的时候，只有 1 种可能。</p>
<p>那如果我们要到达第二个台阶，我们要不就是连续爬 2 次 1 个跨度，要不就是一次性爬两个台阶到达第二个台阶。所以有 2 种可能性。</p>
<p>那如果是需要到达<strong>第三个台阶呢</strong>？</p>
<blockquote>
<p>这里有个小技巧，要到达第三个台阶我们可以换一种思维去想，如果我们还是像第一个和第二个台阶的方式去列出可以到达第三个台阶的所有可能性，那如果<code>n</code>很大的时候，我们只靠人的大脑去想，那真的是太费劲了。但是这里有一个很巧妙的思维方式。</p>
<br/>
返过来想，我们想到达第三个台阶，只有两种可能可以到达：

<ol>
<li>要不就是从第二个台阶爬 1 个台阶到达</li>
<li>要不就是从第一个台阶爬 2 个台阶到达</li>
</ol>
<br/>
那其实如果是第四个台阶是不是也是一样的？

<ol>
<li>要不就是从第三个台阶爬 1 个台阶到达</li>
<li>要不就是从第二个台阶爬 2 个台阶到达</li>
</ol>
<br/>
这里就有一个`规律`了。要到达第`n`个台阶我们需要知道：

<ol>
<li>到达第<code>n-1</code>的台阶有多少种可能</li>
<li>到达第<code>n-2</code>的台阶有多少种可能</li>
<li>然后这两个相加就是到达第<code>n</code>的台阶有多少种可能</li>
</ol>
</blockquote>
<p>那其实这里就是老生常谈的<code>斐波拉次</code>数列:</p>
<p>$f(n) = f(n-1) + f(n-2)$</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><strong>斐波拉次（Fibonacci）</strong>- “傻递归“<ul>
<li>直接使用递归循环使用斐波拉次公式即可</li>
<li>但是时间复杂度就很高 - $O(2^n)$</li>
</ul>
</li>
<li><strong>动态规划</strong><ul>
<li>用上面讲到的原理，到达第<code>n</code>个台阶只需要：爬上 $n-1$ 台阶的方式数 + 爬上 $n - 2$ 台阶的方法数 = 爬上第 $n$ 个台阶的方式数</li>
<li>所以得出的公式是 $dp[n] = dp[n-1] + dp[n-2]$</li>
<li>同时需要初始化： $dp[0]=1$ 和 $dp[1] = 1$</li>
<li>使用这种方式时间复杂度降到 $O(n)$</li>
</ul>
</li>
<li>动态规划 2 - 只记录最后 3 个的方法量<ul>
<li>与上面的动态规划的方法一样，但是这里我们只记录最后 3 个的台阶的爬楼方法数</li>
<li>使用<code>f1</code>，<code>f2</code>，<code>f3</code>作为储存变量</li>
<li>默认 $f1 = 1$ 和 $f2 = 2$ 即可</li>
</ul>
</li>
<li>通项公式（Binet’s Formular ）<ul>
<li>有观察数学规律的同学，或者数学比较好的同学，会发现本题是斐波那次数列，那么我们也可以用斐波那次的“通项公式”</li>
<li>公式是：$F_n = \frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n]$</li>
<li>时间复杂度：$O(logn)$</li>
</ul>
</li>
</ol>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><p><strong>「方法一」斐波那次</strong></p>
<ul>
<li>时间复杂度：$O(2^n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="javascript">/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  if (n &lt;= 2) return n;
  return climbStairs(n - 1) + climbStairs(n - 2);
};</code></pre>
<p><strong>「方法二」动态规划</strong></p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
<pre><code class="javascript">/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  const dp = [];
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i &lt;= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n];
};</code></pre>
<p><strong>「方法三」动态规划 2</strong></p>
<ul>
<li>时间复杂度：$O(n)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="javascript">/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  if (n &lt;= 2) {
    return n;
  }
  let f1 = 1,
    f2 = 2,
    f3;
  for (let i = 3; i &lt;= n; i++) {
    f3 = f1 + f2;
    f1 = f2;
    f2 = f3;
  }
  return f3;
};</code></pre>
<p><strong>「方法四」通项公式</strong></p>
<ul>
<li>时间复杂度：$O(logn)$</li>
<li>空间复杂度：$O(1)$</li>
</ul>
<pre><code class="javascript">/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  const sqrt_5 = Math.sqrt(5);
  const fib_n = Math.pow((1 + sqrt_5) / 2, n + 1) - Math.pow((1 - sqrt_5) / 2, n + 1);
  return Math.round(fib_n / sqrt_5);
};</code></pre>
<h2 id="题解对比与分析-2"><a href="#题解对比与分析-2" class="headerlink" title="题解对比与分析"></a>题解对比与分析</h2><table>
<thead>
<tr>
<th>方法</th>
<th>执行时间（毫秒）</th>
<th>内存消耗</th>
</tr>
</thead>
<tbody><tr>
<td>「方法一」斐波那次</td>
<td>超出时间限制</td>
<td>N/A</td>
</tr>
<tr>
<td>「方法二」动态规划</td>
<td>68 ms</td>
<td>32.4 MB</td>
</tr>
<tr>
<td>「方法三」动态规划 2</td>
<td>53 ms</td>
<td>32.3 MB</td>
</tr>
<tr>
<td>「方法三」通项公式</td>
<td>67 ms</td>
<td>32.4 MB</td>
</tr>
</tbody></table>
<p><strong>分析一下</strong></p>
<ul>
<li>按照时间复杂度来说，应该“<strong>通项公式</strong>”是性能最优的，但是力扣的执行时间不是很靠谱，这一点我在上面也说到，就不多解释了。</li>
<li>所以最优解还是第三种方法“<strong>通项公式</strong>”</li>
<li>接着就是“<strong>动态规划 2</strong>”，因为只储存了 3 个变量，第二种方法需要用到数组。在空间复杂度上就占了优势。</li>
<li>而最后输一下傻瓜式的斐波那次递归，这种方法还没有执行完就已经被淘汰了。时间复杂度过高。</li>
</ul>
<h1 id="推荐专栏"><a href="#推荐专栏" class="headerlink" title="推荐专栏"></a>推荐专栏</h1><p>小伙伴们可以<strong>查看或者订阅相关的专栏</strong>，从而集中阅读相关知识的文章哦。</p>
<ul>
<li><p>📖 <a href="https://blog.csdn.net/tridiamond6/category_10036942.html" target="_blank" rel="noopener">《数据结构与算法》</a> — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。</p>
</li>
<li><p>📖 <a href="https://blog.csdn.net/tridiamond6/category_9782493.html" target="_blank" rel="noopener">《FCC 前端集训营》</a> — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书</p>
</li>
<li><p>📖 <a href="https://blog.csdn.net/tridiamond6/category_9782493.html" target="_blank" rel="noopener">《前端星球》</a> — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥</p>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='ec894e2b66f752e8b7fb'
        data-cs='3ccc2e92bb350688fe2c2dc2930189b62622bfb1'
        data-r='blog-comments'
        data-o='TriDiamond'
        data-a='TriDiamond'
        data-d=''
    >留言</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="https://res.cloudinary.com/tridiamond/image/upload/v1573019751/TriDiamond_logo_ui_xeublz.jpg" height=300 width=300></img>
                    <p>三·钻 TriDiamond</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        <dd><a href="https://github.com/TriDiamond" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                        <dd><a href="https://twitter.com/TriDiamond6" target="_blank"><span
                                    class=" iconfont icon-twitter"></span></a></dd>
                        <dd><a href="https://stackoverflow.com/users/7602324/tridiamond?tab=profile" target="_blank"><span
                                    class=" iconfont icon-stack-overflow"></span></a></dd>
                    </dl>
                </div>
                <ul>
                    <li><a href="/">32 <p>文章</p></a></li>
                    <li><a href="/categories">13 <p>分类</p></a></li>
                    <li><a href="/tags">42 <p>标签</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>目录</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#练题法则"><span class="toc-number">1.</span> <span class="toc-text">练题法则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在哪里练题？"><span class="toc-number">1.1.</span> <span class="toc-text">在哪里练题？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#283-题-移动零"><span class="toc-number">2.</span> <span class="toc-text">283 题 - 移动零</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目讲解"><span class="toc-number">2.1.</span> <span class="toc-text">题目讲解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路"><span class="toc-number">2.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题代码"><span class="toc-number">2.3.</span> <span class="toc-text">解题代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#边界测试用例"><span class="toc-number">2.4.</span> <span class="toc-text">边界测试用例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解对比与分析"><span class="toc-number">2.5.</span> <span class="toc-text">题解对比与分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-题-盛最多水的容器"><span class="toc-number">3.</span> <span class="toc-text">11 题 - 盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目讲解-1"><span class="toc-number">3.1.</span> <span class="toc-text">题目讲解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路-1"><span class="toc-number">3.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题代码-1"><span class="toc-number">3.3.</span> <span class="toc-text">解题代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解对比与分析-1"><span class="toc-number">3.4.</span> <span class="toc-text">题解对比与分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#70-题-爬楼梯"><span class="toc-number">4.</span> <span class="toc-text">70 题 - 爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目讲解-2"><span class="toc-number">4.1.</span> <span class="toc-text">题目讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题解重点"><span class="toc-number">4.1.1.</span> <span class="toc-text">题解重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深度分析题目："><span class="toc-number">4.1.2.</span> <span class="toc-text">深度分析题目：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路-2"><span class="toc-number">4.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题代码-2"><span class="toc-number">4.3.</span> <span class="toc-text">解题代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题解对比与分析-2"><span class="toc-number">4.4.</span> <span class="toc-text">题解对比与分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#推荐专栏"><span class="toc-number">5.</span> <span class="toc-text">推荐专栏</span></a></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2021
        <span class="gradient-text">
            三·钻 TriDiamond
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.4" target="_blank" rel="noopener">v1.4.4</a></small>
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-149874671-1');
</script>
 

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




</html>
